"use strict";
/** [[include:doc/maybe.md]] */
Object.defineProperty(exports, "__esModule", { value: true });
/** (keep typedoc from getting confused by the imports) */
const result_1 = require("./result");
const utils_1 = require("./utils");
/**
  Discriminant for the `Just` and `Nothing` variants.

  You can use the discriminant via the `variant` property of `Maybe` instances
  if you need to match explicitly on it.
 */
var Variant;
(function (Variant) {
    Variant["Just"] = "Just";
    Variant["Nothing"] = "Nothing";
})(Variant = exports.Variant || (exports.Variant = {}));
/**
  A `Just` instance is the *present* variant instance of the
  [`Maybe`](../modules/_maybe_.html#maybe) type, representing the presence of a
  value which may be absent. For a full discussion, see [the module
  docs](../modules/_maybe_.html).

  @typeparam T The type wrapped in this `Just` variant of `Maybe`.
 */
class Just {
    /**
      Create an instance of `Maybe.Just` with `new`.
  
      @note While you *may* create the `Just` type via normal JavaScript
      class construction, it is not recommended for the functional style for
      which the library is intended. Instead, use [`Maybe.of`] (for the general
      case) or [`Maybe.just`] for this specific case.
  
      [`Maybe.of`]: ../modules/_maybe_.html#of
      [`Maybe.just`]: ../modules/_maybe_.html#just
  
      ```ts
      // Avoid:
      const aString = new Maybe.Just('characters');
  
      // Prefer:
      const aString = Maybe.just('characters);
      ```
  
      @param value
      The value to wrap in a `Maybe.Just`.
  
      `null` and `undefined` are allowed by the type signature so that the
      constructor may `throw` on those rather than constructing a type like
      `Maybe<undefined>`.
  
      @throws      If you pass `null` or `undefined`.
     */
    constructor(value) {
        /** `Just` is always [`Variant.Just`](../enums/_maybe_.variant#just). */
        this.variant = Variant.Just;
        if (utils_1.isVoid(value)) {
            throw new Error('Tried to construct `Just` with `null` or `undefined`');
        }
        this.value = value;
    }
    /**
      Unwrap the contained value. A convenience method for functional idioms.
  
      A common scenario where you might want to use this is in a pipeline of
      functions:
  
      ```ts
      import Maybe, { Just } from 'true-myth/maybe';
  
      function getLengths(maybeStrings: Array<Maybe<string>>): Array<number> {
        return maybeStrings
          .filter(Maybe.isJust)
          .map(Just.unwrap)
          .map(s => s.length);
      }
      ```
     */
    static unwrap(theJust) {
        return theJust.value;
    }
    /** Method variant for [`Maybe.isJust`](../modules/_maybe_.html#isjust) */
    isJust() {
        return true;
    }
    /** Method variant for [`Maybe.isNothing`](../modules/_maybe_.html#isnothing) */
    isNothing() {
        return false;
    }
    /** Method variant for [`Maybe.map`](../modules/_maybe_.html#map) */
    map(mapFn) {
        return map(mapFn, this);
    }
    /** Method variant for [`Maybe.mapOr`](../modules/_maybe_.html#mapor) */
    mapOr(orU, mapFn) {
        return mapOr(orU, mapFn, this);
    }
    /** Method variant for [`Maybe.mapOrElse`](../modules/_maybe_.html#maporelse) */
    mapOrElse(orElseFn, mapFn) {
        return mapOrElse(orElseFn, mapFn, this);
    }
    /** Method variant for [`Maybe.match`](../modules/_maybe_.html#match) */
    match(matcher) {
        return match(matcher, this);
    }
    /** Method variant for [`Maybe.or`](../modules/_maybe_.html#or) */
    or(mOr) {
        return or(mOr, this);
    }
    /** Method variant for [`Maybe.orElse`](../modules/_maybe_.html#orelse) */
    orElse(orElseFn) {
        return orElse(orElseFn, this);
    }
    /** Method variant for [`Maybe.and`](../modules/_maybe_.html#and) */
    and(mAnd) {
        return and(mAnd, this);
    }
    /** Method variant for [`Maybe.andThen`](../modules/_maybe_.html#andthen) */
    andThen(andThenFn) {
        return andThen(andThenFn, this);
    }
    /** Method variant for [`Maybe.chain`](../modules/_maybe_.html#chain) */
    chain(chainFn) {
        return this.andThen(chainFn);
    }
    /** Method variant for [`Maybe.flatMap`](../modules/_maybe_.html#flatmap) */
    flatMap(flatMapFn) {
        return this.andThen(flatMapFn);
    }
    /** Method variant for [`Maybe.unsafelyUnwrap`](../modules/_maybe_.html#unsafelyunwrap) */
    unsafelyUnwrap() {
        return this.value;
    }
    /** Method variant for [`Maybe.unwrapOr`](../modules/_maybe_.html#unwrapor) */
    unwrapOr(defaultValue) {
        return unwrapOr(defaultValue, this);
    }
    /** Method variant for [`Maybe.unwrapOrElse`](../modules/_maybe_.html#unwraporelse) */
    unwrapOrElse(elseFn) {
        return unwrapOrElse(elseFn, this);
    }
    /** Method variant for [`Maybe.toOkOrErr`](../modules/_maybe_.html#tookorerr) */
    toOkOrErr(error) {
        return toOkOrErr(error, this);
    }
    /** Method variant for [`Maybe.toOkOrElseErr`](../modules/_maybe_.html#tookorelseerr) */
    toOkOrElseErr(elseFn) {
        return toOkOrElseErr(elseFn, this);
    }
    /** Method variant for [`Maybe.toString`](../modules/_maybe_.html#tostring) */
    toString() {
        return toString(this);
    }
    /** Method variant for [`Maybe.equals`](../modules/_maybe_.html#equals) */
    equals(comparison) {
        return equals(comparison, this);
    }
    /** Method variant for [`Maybe.ap`](../modules/_maybe_.html#ap) */
    ap(val) {
        return ap(this, val);
    }
}
exports.Just = Just;
/**
  A `Nothing` instance is the *absent* variant instance of the
  [`Maybe`](../modules/_maybe_.html#maybe) type, representing the presence of a
  value which may be absent. For a full discussion, see [the module
  docs](../modules/_maybe_.html).

  @typeparam T The type which would be wrapped in a `Just` variant of `Maybe`.
 */
class Nothing {
    /**
      Create an instance of `Maybe.Nothing` with `new`.
  
      @note While you *may* create the `Nothing` type via normal JavaScript
      class construction, it is not recommended for the functional style for
      which the library is intended. Instead, use [`Maybe.of`] (for the general
      case) or [`Maybe.nothing`] for this specific case.
  
      [`Maybe.of`]: ../modules/_maybe_.html#of
      [`Maybe.nothing`]: ../modules/_maybe_.html#nothing
  
      ```ts
      // Avoid:
      const aNothing = new Maybe.Err();
  
      // Prefer:
      const aNothing = Maybe.nothing();
      ```
  
      `null` and `undefined` are allowed so that you may explicitly construct the
      `Err` type with a known `null` or `undefined` value. (This maybe helpful
      primarily when transitioning a codebase to the use of `Maybe`.)
  
      @throws      If you pass `null` or `undefined`.
     */
    constructor(_) {
        /** `Nothing` is always [`Variant.Nothing`](../enums/_maybe_.variant#nothing). */
        this.variant = Variant.Nothing;
        /* nothing to do */
    }
    /** Method variant for [`Maybe.isJust`](../modules/_maybe_.html#isjust) */
    isJust() {
        return false;
    }
    /** Method variant for [`Maybe.isNothing`](../modules/_maybe_.html#isnothing) */
    isNothing() {
        return true;
    }
    /** Method variant for [`Maybe.map`](../modules/_maybe_.html#map) */
    map(mapFn) {
        return map(mapFn, this);
    }
    /** Method variant for [`Maybe.mapOr`](../modules/_maybe_.html#mapor) */
    mapOr(orU, mapFn) {
        return mapOr(orU, mapFn, this);
    }
    /** Method variant for [`Maybe.mapOrElse`](../modules/_maybe_.html#maporelse) */
    mapOrElse(orElseFn, mapFn) {
        return mapOrElse(orElseFn, mapFn, this);
    }
    /** Method variant for [`Maybe.match`](../modules/_maybe_.html#match) */
    match(matcher) {
        return match(matcher, this);
    }
    /** Method variant for [`Maybe.or`](../modules/_maybe_.html#or) */
    or(mOr) {
        return or(mOr, this);
    }
    /** Method variant for [`Maybe.orElse`](../modules/_maybe_.html#orelse) */
    orElse(orElseFn) {
        return orElse(orElseFn, this);
    }
    /** Method variant for [`Maybe.and`](../modules/_maybe_.html#and) */
    and(mAnd) {
        return and(mAnd, this);
    }
    /** Method variant for [`Maybe.andThen`](../modules/_maybe_.html#andthen) */
    andThen(andThenFn) {
        return andThen(andThenFn, this);
    }
    /** Method variant for [`Maybe.chain`](../modules/_maybe_.html#chain) */
    chain(chainFn) {
        return this.andThen(chainFn);
    }
    /** Method variant for [`Maybe.flatMap`](../modules/_maybe_.html#flatmap) */
    flatMap(flatMapFn) {
        return this.andThen(flatMapFn);
    }
    /** Method variant for [`Maybe.unsafelyUnwrap`](../modules/_maybe_.html#unsafelyunwrap) */
    unsafelyUnwrap() {
        throw new Error('Tried to `unsafelyUnwrap(Nothing)`');
    }
    /** Method variant for [`Maybe.unwrapOr`](../modules/_maybe_.html#unwrapor) */
    unwrapOr(defaultValue) {
        return unwrapOr(defaultValue, this);
    }
    /** Method variant for [`Maybe.unwrapOrElse`](../modules/_maybe_.html#unwraporelse) */
    unwrapOrElse(elseFn) {
        return unwrapOrElse(elseFn, this);
    }
    /** Method variant for [`Maybe.toOkOrErr`](../modules/_maybe_.html#tookorerr) */
    toOkOrErr(error) {
        return toOkOrErr(error, this);
    }
    /** Method variant for [`Maybe.toOkOrElseErr`](../modules/_maybe_.html#tookorelseerr) */
    toOkOrElseErr(elseFn) {
        return toOkOrElseErr(elseFn, this);
    }
    /** Method variant for [`Maybe.toString`](../modules/_maybe_.html#tostring) */
    toString() {
        return toString(this);
    }
    /** Method variant for [`Maybe.equals`](../modules/_maybe_.html#equals) */
    equals(comparison) {
        return equals(comparison, this);
    }
    /** Method variant for [`Maybe.ap`](../modules/_maybe_.html#ap) */
    ap(val) {
        return ap(this, val);
    }
}
exports.Nothing = Nothing;
/**
  Is this result a `Just` instance?

  @typeparam T The type of the wrapped value.
  @param maybe The `Maybe` instance to check.
  @returns     `true` if `maybe` is `Just`, `false` otherwise. In TypeScript,
               also narrows the type from `Maybe<T>` to `Just<T>`.
 */
function isJust(maybe) {
    return maybe.variant === Variant.Just;
}
exports.isJust = isJust;
/**
  Is this result a `Nothing` instance?

  @typeparam T The type of the wrapped value.
  @param maybe The `Maybe` instance to check.
  @returns     `true` if `maybe` is `nothing`, `false` otherwise. In TypeScript,
               also narrows the type from `Maybe<T>` to `Nothing<T>`.
 */
function isNothing(maybe) {
    return maybe.variant === Variant.Nothing;
}
exports.isNothing = isNothing;
/**
  Create an instance of `Maybe.Just`.

  `null` and `undefined` are allowed by the type signature so that the
  function may `throw` on those rather than constructing a type like
  `Maybe<undefined>`.

  @typeparam T The type of the item contained in the `Maybe`.
  @param value The value to wrap in a `Maybe.Just`.
  @returns     An instance of `Maybe.Just<T>`.
  @throws      If you pass `null` or `undefined`.
 */
function just(value) {
    return new Just(value);
}
exports.just = just;
/**
  Create an instance of `Maybe.Nothing`.

  If you want to create an instance with a specific type, e.g. for use in a
  function which expects a `Maybe<T>` where the `<T>` is known but you have no
  value to give it, you can use a type parameter:

  ```ts
  const notString = Maybe.nothing<string>();
  ```

  @typeparam T The type of the item contained in the `Maybe`.
  @returns     An instance of `Maybe.Nothing<T>`.
 */
function nothing(_) {
    return new Nothing(_);
}
exports.nothing = nothing;
/**
  Create a `Maybe` from any value.

  To specify that the result should be interpreted as a specific type, you may
  invoke `Maybe.of` with an explicit type parameter:

  ```ts
  const foo = Maybe.of<string>(null);
  ```

  This is usually only important in two cases:

  1.  If you are intentionally constructing a `Nothing` from a known `null` or
      undefined value *which is untyped*.
  2.  If you are specifying that the type is more general than the value passed
      (since TypeScript can define types as literals).

  @typeparam T The type of the item contained in the `Maybe`.
  @param value The value to wrap in a `Maybe`. If it is `undefined` or `null`,
               the result will be `Nothing`; otherwise it will be the type of
               the value passed.
 */
function of(value) {
    return utils_1.isVoid(value) ? nothing() : just(value);
}
exports.of = of;
/** Alias for [`of`](#of), primarily for compatibility with Folktale. */
exports.fromNullable = of;
function map(mapFn, maybe) {
    const op = (m) => (m.isJust() ? just(mapFn(m.value)) : nothing());
    return utils_1.curry1(op, maybe);
}
exports.map = map;
function mapOr(orU, mapFn, maybe) {
    function fullOp(fn, m) {
        return m.isJust() ? fn(m.value) : orU;
    }
    function partialOp(fn, curriedMaybe) {
        return curriedMaybe !== undefined
            ? fullOp(fn, curriedMaybe)
            : (extraCurriedMaybe) => fullOp(fn, extraCurriedMaybe);
    }
    return mapFn === undefined
        ? partialOp
        : maybe === undefined
            ? partialOp(mapFn)
            : partialOp(mapFn, maybe);
}
exports.mapOr = mapOr;
function mapOrElse(orElseFn, mapFn, maybe) {
    function fullOp(fn, m) {
        return m.isJust() ? fn(m.value) : orElseFn();
    }
    function partialOp(fn, curriedMaybe) {
        return curriedMaybe !== undefined
            ? fullOp(fn, curriedMaybe)
            : (extraCurriedMaybe) => fullOp(fn, extraCurriedMaybe);
    }
    if (mapFn === undefined) {
        return partialOp;
    }
    else if (maybe === undefined) {
        return partialOp(mapFn);
    }
    else {
        return partialOp(mapFn, maybe);
    }
}
exports.mapOrElse = mapOrElse;
function and(andMaybe, maybe) {
    const op = (m) => (m.isJust() ? andMaybe : nothing());
    return utils_1.curry1(op, maybe);
}
exports.and = and;
function andThen(thenFn, maybe) {
    const op = (m) => (m.isJust() ? thenFn(m.value) : nothing());
    return maybe !== undefined ? op(maybe) : op;
}
exports.andThen = andThen;
/** Alias for [`andThen`](#andthen). */
exports.chain = andThen;
/** Alias for [`andThen`](#andthen). */
exports.flatMap = andThen;
function or(defaultMaybe, maybe) {
    const op = (m) => (m.isJust() ? m : defaultMaybe);
    return maybe !== undefined ? op(maybe) : op;
}
exports.or = or;
function orElse(elseFn, maybe) {
    const op = (m) => (m.isJust() ? m : elseFn());
    return utils_1.curry1(op, maybe);
}
exports.orElse = orElse;
/**
  Get the value out of the `Maybe`.

  Returns the content of a `Just`, but **throws if the `Maybe` is `Nothing`**.
  Prefer to use [`unwrapOr`](#unwrapor) or [`unwrapOrElse`](#unwraporelse).

  @typeparam T The type of the wrapped value.
  @param maybe The value to unwrap
  @returns     The unwrapped value if the `Maybe` instance is `Just`.
  @throws      If the `maybe` is `Nothing`.
 */
function unsafelyUnwrap(maybe) {
    return maybe.unsafelyUnwrap();
}
exports.unsafelyUnwrap = unsafelyUnwrap;
/** Alias for [`unsafelyUnwrap`](#unsafelyunwrap) */
exports.unsafelyGet = unsafelyUnwrap;
/** Alias for [`unsafelyUnwrap`](#unsafelyunwrap) */
exports.unsafeGet = unsafelyUnwrap;
function unwrapOr(defaultValue, maybe) {
    const op = (m) => (m.isJust() ? m.value : defaultValue);
    return utils_1.curry1(op, maybe);
}
exports.unwrapOr = unwrapOr;
/** Alias for [`unwrapOr`](#unwrapor) */
exports.getOr = unwrapOr;
function unwrapOrElse(orElseFn, maybe) {
    const op = (m) => (m.isJust() ? m.value : orElseFn());
    return utils_1.curry1(op, maybe);
}
exports.unwrapOrElse = unwrapOrElse;
/** Alias for [`unwrapOrElse`](#unwraporelse) */
exports.getOrElse = unwrapOrElse;
function toOkOrErr(error, maybe) {
    const op = (m) => (m.isJust() ? result_1.ok(m.value) : result_1.err(error));
    return maybe !== undefined ? op(maybe) : op;
}
exports.toOkOrErr = toOkOrErr;
function toOkOrElseErr(elseFn, maybe) {
    const op = (m) => (m.isJust() ? result_1.ok(m.value) : result_1.err(elseFn()));
    return utils_1.curry1(op, maybe);
}
exports.toOkOrElseErr = toOkOrElseErr;
/**
  Construct a `Maybe<T>` from a `Result<T, E>`.

  If the `Result` is an `Ok`, wrap its value in `Just`. If the `Result` is an
  `Err`, throw away the wrapped `E` and transform to a `Nothing`.

  @typeparam T  The type of the value wrapped in a `Result.Ok` and in the `Just`
                of the resulting `Maybe`.
  @typeparam E  The type of the value wrapped in a `Result.Err`; thrown away in
                the resulting `Maybe`.
  @param result The `Result` to construct a `Maybe` from.
  @returns      `Just` if `result` was `Ok` or `Nothing` if it was `Err`.
 */
function fromResult(result) {
    return result.isOk() ? just(result.value) : nothing();
}
exports.fromResult = fromResult;
/**
  Create a `String` representation of a `Maybe` instance.

  A `Just` instance will be printed as `Just(<representation of the value>)`,
  where the representation of the value is simply the value's own `toString`
  representation. For example:

  | call                                   | output                  |
  |----------------------------------------|-------------------------|
  | `toString(Maybe.of(42))`               | `Just(42)`              |
  | `toString(Maybe.of([1, 2, 3]))`        | `Just(1,2,3)`           |
  | `toString(Maybe.of({ an: 'object' }))` | `Just([object Object])` |
  | `toString(Maybe.nothing())`            | `Nothing`               |

  @typeparam T The type of the wrapped value; its own `.toString` will be used
               to print the interior contents of the `Just` variant.
  @param maybe The value to convert to a string.
  @returns     The string representation of the `Maybe`.
 */
function toString(maybe) {
    const body = maybe.isJust() ? `(${maybe.value.toString()})` : '';
    return `${maybe.variant}${body}`;
}
exports.toString = toString;
function match(matcher, maybe) {
    return maybe !== undefined
        ? mapOrElse(matcher.Nothing, matcher.Just, maybe)
        : (curriedMaybe) => mapOrElse(matcher.Nothing, matcher.Just, curriedMaybe);
}
exports.match = match;
/** Alias for [`match`](#match) */
exports.cata = match;
function equals(mb, ma) {
    return ma !== undefined
        ? ma.match({
            Just: aVal => mb.isJust() && mb.unsafelyUnwrap() === aVal,
            Nothing: () => isNothing(mb),
        })
        : (maybeA) => maybeA.match({
            Nothing: () => isNothing(mb),
            Just: aVal => mb.isJust() && mb.unsafelyUnwrap() === aVal,
        });
}
exports.equals = equals;
function ap(maybeFn, maybe) {
    const op = (m) => m.match({
        Just: val => maybeFn.map(fn => fn(val)),
        Nothing: () => exports.Maybe.nothing(),
    });
    return utils_1.curry1(op, maybe);
}
exports.ap = ap;
/**
  Determine whether an item is an instance of `Just` or `Nothing`.

  @param item The item to check.
 */
function isInstance(item) {
    return item instanceof Just || item instanceof Nothing;
}
exports.isInstance = isInstance;
function find(predicate, array) {
    const op = (a) => exports.Maybe.of(a.find(predicate));
    return utils_1.curry1(op, array);
}
exports.find = find;
/**
  Safely get the first item from a list, returning `Just` the first item if the
  array has at least one item in it, or `Nothing` if it is empty.

  ## Examples

  ```ts
  let empty = [];
  Maybe.head(empty); // => Nothing

  let full = [1, 2, 3];
  Maybe.head(full); // => Just(1)
  ```

  @param array The array to get the first item from.
 */
function head(array) {
    return exports.Maybe.of(array[0]);
}
exports.head = head;
/** A convenience alias for `Maybe.head`. */
exports.first = head;
/**
  Safely get the last item from a list, returning `Just` the last item if the
  array has at least one item in it, or `Nothing` if it is empty.

  ## Examples

  ```ts
  let empty = [];
  Maybe.last(empty); // => Nothing

  let full = [1, 2, 3];
  Maybe.last(full); // => Just(3)
  ```

  @param array The array to get the first item from.
 */
function last(array) {
    return exports.Maybe.of(array[array.length - 1]);
}
exports.last = last;
/**
  Convert the arguments to a single `Maybe`. Useful for dealing with arrays of
  `Maybe`s, via the spread operator.

  ## Examples

  ```ts
  import Maybe from 'true-myth/maybe';

  let valid = [Maybe.just(2), Maybe.just('three')];
  Maybe.all(...valid); // => Just([2, 'three']);

  let invalid = [Maybe.just(2), Maybe.nothing<string>()];
  Maybe.all(...invalid); // => Nothing
  ```

  ## Note on Spread

  This requires the use of the spread operator because (at least as of
  TypeScript 3.0), the type inference falls down when attempting to build this
  same type with an array directly. Moreover, this spread-based approach handles
  heteregenous arrays; TS *also* fails to infer correctly for anything but
  homogeneous arrays when using that approach.

  @param args The `Maybe`s to resolve to a single `Maybe`.
 */
function all(...args) {
    // @ts-ignore -- this is indeed the correct implementation, but TS doesn't
    //               correctly parse the types in the context of `reduce`.
    return args.reduce((result, maybe) => result.andThen(as => maybe.map(a => as.concat(a))), exports.Maybe.just([]));
}
exports.all = all;
function tuple(maybes) {
    // @ts-ignore -- this doesn't type-check, but it is correct!
    return all(...maybes);
}
exports.tuple = tuple;
exports.Maybe = {
    Variant,
    Just,
    Nothing,
    all,
    isJust,
    isNothing,
    just,
    nothing,
    of,
    find,
    first: exports.first,
    fromNullable: exports.fromNullable,
    head,
    last,
    map,
    mapOr,
    mapOrElse,
    and,
    andThen,
    chain: exports.chain,
    flatMap: exports.flatMap,
    or,
    orElse,
    unsafelyUnwrap,
    unsafelyGet: exports.unsafelyGet,
    unsafeGet: exports.unsafeGet,
    unwrapOr,
    getOr: exports.getOr,
    unwrapOrElse,
    getOrElse: exports.getOrElse,
    toOkOrErr,
    toOkOrElseErr,
    fromResult,
    toString,
    tuple,
    match,
    cata: exports.cata,
    equals,
    ap,
    isInstance,
};
exports.default = exports.Maybe;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF5YmUuanMiLCJzb3VyY2VSb290IjoiLi8iLCJzb3VyY2VzIjpbIm1heWJlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSwrQkFBK0I7O0FBRS9CLDBEQUEwRDtBQUMxRCxxQ0FBMkM7QUFDM0MsbUNBQXlDO0FBRXpDOzs7OztHQUtHO0FBQ0gsSUFBWSxPQUdYO0FBSEQsV0FBWSxPQUFPO0lBQ2pCLHdCQUFhLENBQUE7SUFDYiw4QkFBbUIsQ0FBQTtBQUNyQixDQUFDLEVBSFcsT0FBTyxHQUFQLGVBQU8sS0FBUCxlQUFPLFFBR2xCO0FBaUVEOzs7Ozs7O0dBT0c7QUFDSCxNQUFhLElBQUk7SUE0QmY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQTJCRztJQUNILFlBQVksS0FBZ0I7UUFsQzVCLHdFQUF3RTtRQUMvRCxZQUFPLEdBQWlCLE9BQU8sQ0FBQyxJQUFJLENBQUM7UUFrQzVDLElBQUksY0FBTSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ2pCLE1BQU0sSUFBSSxLQUFLLENBQUMsc0RBQXNELENBQUMsQ0FBQztTQUN6RTtRQUVELElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO0lBQ3JCLENBQUM7SUE3REQ7Ozs7Ozs7Ozs7Ozs7Ozs7T0FnQkc7SUFDSCxNQUFNLENBQUMsTUFBTSxDQUFJLE9BQWdCO1FBQy9CLE9BQU8sT0FBTyxDQUFDLEtBQUssQ0FBQztJQUN2QixDQUFDO0lBNENELDBFQUEwRTtJQUMxRSxNQUFNO1FBQ0osT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQsZ0ZBQWdGO0lBQ2hGLFNBQVM7UUFDUCxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFRCxvRUFBb0U7SUFDcEUsR0FBRyxDQUFvQixLQUFrQjtRQUN2QyxPQUFPLEdBQUcsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDMUIsQ0FBQztJQUVELHdFQUF3RTtJQUN4RSxLQUFLLENBQW9CLEdBQU0sRUFBRSxLQUFrQjtRQUNqRCxPQUFPLEtBQUssQ0FBQyxHQUFHLEVBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ2pDLENBQUM7SUFFRCxnRkFBZ0Y7SUFDaEYsU0FBUyxDQUFvQixRQUFpQixFQUFFLEtBQWtCO1FBQ2hFLE9BQU8sU0FBUyxDQUFDLFFBQVEsRUFBRSxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDMUMsQ0FBQztJQUVELHdFQUF3RTtJQUN4RSxLQUFLLENBQW9CLE9BQXNCO1FBQzdDLE9BQU8sS0FBSyxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztJQUM5QixDQUFDO0lBRUQsa0VBQWtFO0lBQ2xFLEVBQUUsQ0FBaUIsR0FBYTtRQUM5QixPQUFPLEVBQUUsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDdkIsQ0FBQztJQUVELDBFQUEwRTtJQUMxRSxNQUFNLENBQWlCLFFBQXdCO1FBQzdDLE9BQU8sTUFBTSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNoQyxDQUFDO0lBRUQsb0VBQW9FO0lBQ3BFLEdBQUcsQ0FBb0IsSUFBYztRQUNuQyxPQUFPLEdBQUcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDekIsQ0FBQztJQUVELDRFQUE0RTtJQUM1RSxPQUFPLENBQW9CLFNBQTZCO1FBQ3RELE9BQU8sT0FBTyxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNsQyxDQUFDO0lBRUQsd0VBQXdFO0lBQ3hFLEtBQUssQ0FBb0IsT0FBMkI7UUFDbEQsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQy9CLENBQUM7SUFFRCw0RUFBNEU7SUFDNUUsT0FBTyxDQUFvQixTQUE2QjtRQUN0RCxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDakMsQ0FBQztJQUVELDBGQUEwRjtJQUMxRixjQUFjO1FBQ1osT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDO0lBQ3BCLENBQUM7SUFFRCw4RUFBOEU7SUFDOUUsUUFBUSxDQUFpQixZQUFlO1FBQ3RDLE9BQU8sUUFBUSxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsQ0FBQztJQUN0QyxDQUFDO0lBRUQsc0ZBQXNGO0lBQ3RGLFlBQVksQ0FBaUIsTUFBZTtRQUMxQyxPQUFPLFlBQVksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDcEMsQ0FBQztJQUVELGdGQUFnRjtJQUNoRixTQUFTLENBQW9CLEtBQVE7UUFDbkMsT0FBTyxTQUFTLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ2hDLENBQUM7SUFFRCx3RkFBd0Y7SUFDeEYsYUFBYSxDQUFvQixNQUFlO1FBQzlDLE9BQU8sYUFBYSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRUQsOEVBQThFO0lBQzlFLFFBQVE7UUFDTixPQUFPLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN4QixDQUFDO0lBRUQsMEVBQTBFO0lBQzFFLE1BQU0sQ0FBaUIsVUFBb0I7UUFDekMsT0FBTyxNQUFNLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ2xDLENBQUM7SUFFRCxrRUFBa0U7SUFDbEUsRUFBRSxDQUFtQyxHQUFhO1FBQ2hELE9BQU8sRUFBRSxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQztJQUN2QixDQUFDO0NBQ0Y7QUFuS0Qsb0JBbUtDO0FBRUQ7Ozs7Ozs7R0FPRztBQUNILE1BQWEsT0FBTztJQUlsQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Bd0JHO0lBQ0gsWUFBWSxDQUFRO1FBNUJwQixpRkFBaUY7UUFDeEUsWUFBTyxHQUFvQixPQUFPLENBQUMsT0FBTyxDQUFDO1FBNEJsRCxtQkFBbUI7SUFDckIsQ0FBQztJQUVELDBFQUEwRTtJQUMxRSxNQUFNO1FBQ0osT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQsZ0ZBQWdGO0lBQ2hGLFNBQVM7UUFDUCxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRCxvRUFBb0U7SUFDcEUsR0FBRyxDQUFvQixLQUFrQjtRQUN2QyxPQUFPLEdBQUcsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDMUIsQ0FBQztJQUVELHdFQUF3RTtJQUN4RSxLQUFLLENBQW9CLEdBQU0sRUFBRSxLQUFrQjtRQUNqRCxPQUFPLEtBQUssQ0FBQyxHQUFHLEVBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ2pDLENBQUM7SUFFRCxnRkFBZ0Y7SUFDaEYsU0FBUyxDQUFvQixRQUFpQixFQUFFLEtBQWtCO1FBQ2hFLE9BQU8sU0FBUyxDQUFDLFFBQVEsRUFBRSxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDMUMsQ0FBQztJQUVELHdFQUF3RTtJQUN4RSxLQUFLLENBQW9CLE9BQXNCO1FBQzdDLE9BQU8sS0FBSyxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztJQUM5QixDQUFDO0lBRUQsa0VBQWtFO0lBQ2xFLEVBQUUsQ0FBaUIsR0FBYTtRQUM5QixPQUFPLEVBQUUsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDdkIsQ0FBQztJQUVELDBFQUEwRTtJQUMxRSxNQUFNLENBQWlCLFFBQXdCO1FBQzdDLE9BQU8sTUFBTSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNoQyxDQUFDO0lBRUQsb0VBQW9FO0lBQ3BFLEdBQUcsQ0FBb0IsSUFBYztRQUNuQyxPQUFPLEdBQUcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDekIsQ0FBQztJQUVELDRFQUE0RTtJQUM1RSxPQUFPLENBQW9CLFNBQTZCO1FBQ3RELE9BQU8sT0FBTyxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNsQyxDQUFDO0lBRUQsd0VBQXdFO0lBQ3hFLEtBQUssQ0FBb0IsT0FBMkI7UUFDbEQsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQy9CLENBQUM7SUFFRCw0RUFBNEU7SUFDNUUsT0FBTyxDQUFvQixTQUE2QjtRQUN0RCxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDakMsQ0FBQztJQUVELDBGQUEwRjtJQUMxRixjQUFjO1FBQ1osTUFBTSxJQUFJLEtBQUssQ0FBQyxvQ0FBb0MsQ0FBQyxDQUFDO0lBQ3hELENBQUM7SUFFRCw4RUFBOEU7SUFDOUUsUUFBUSxDQUFpQixZQUFlO1FBQ3RDLE9BQU8sUUFBUSxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsQ0FBQztJQUN0QyxDQUFDO0lBRUQsc0ZBQXNGO0lBQ3RGLFlBQVksQ0FBaUIsTUFBZTtRQUMxQyxPQUFPLFlBQVksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDcEMsQ0FBQztJQUVELGdGQUFnRjtJQUNoRixTQUFTLENBQW9CLEtBQVE7UUFDbkMsT0FBTyxTQUFTLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ2hDLENBQUM7SUFFRCx3RkFBd0Y7SUFDeEYsYUFBYSxDQUFvQixNQUFlO1FBQzlDLE9BQU8sYUFBYSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRUQsOEVBQThFO0lBQzlFLFFBQVE7UUFDTixPQUFPLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN4QixDQUFDO0lBRUQsMEVBQTBFO0lBQzFFLE1BQU0sQ0FBaUIsVUFBb0I7UUFDekMsT0FBTyxNQUFNLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ2xDLENBQUM7SUFFRCxrRUFBa0U7SUFDbEUsRUFBRSxDQUFtQyxHQUFhO1FBQ2hELE9BQU8sRUFBRSxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQztJQUN2QixDQUFDO0NBQ0Y7QUFwSUQsMEJBb0lDO0FBRUQ7Ozs7Ozs7R0FPRztBQUNILFNBQWdCLE1BQU0sQ0FBSSxLQUFlO0lBQ3ZDLE9BQU8sS0FBSyxDQUFDLE9BQU8sS0FBSyxPQUFPLENBQUMsSUFBSSxDQUFDO0FBQ3hDLENBQUM7QUFGRCx3QkFFQztBQUVEOzs7Ozs7O0dBT0c7QUFDSCxTQUFnQixTQUFTLENBQUksS0FBZTtJQUMxQyxPQUFPLEtBQUssQ0FBQyxPQUFPLEtBQUssT0FBTyxDQUFDLE9BQU8sQ0FBQztBQUMzQyxDQUFDO0FBRkQsOEJBRUM7QUFFRDs7Ozs7Ozs7Ozs7R0FXRztBQUNILFNBQWdCLElBQUksQ0FBSSxLQUFnQjtJQUN0QyxPQUFPLElBQUksSUFBSSxDQUFJLEtBQUssQ0FBQyxDQUFDO0FBQzVCLENBQUM7QUFGRCxvQkFFQztBQUVEOzs7Ozs7Ozs7Ozs7O0dBYUc7QUFDSCxTQUFnQixPQUFPLENBQUksQ0FBUTtJQUNqQyxPQUFPLElBQUksT0FBTyxDQUFJLENBQUMsQ0FBQyxDQUFDO0FBQzNCLENBQUM7QUFGRCwwQkFFQztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FxQkc7QUFDSCxTQUFnQixFQUFFLENBQUksS0FBZ0I7SUFDcEMsT0FBTyxjQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDcEQsQ0FBQztBQUZELGdCQUVDO0FBRUQsd0VBQXdFO0FBQzNELFFBQUEsWUFBWSxHQUFHLEVBQUUsQ0FBQztBQThDL0IsU0FBZ0IsR0FBRyxDQUNqQixLQUFrQixFQUNsQixLQUFnQjtJQUVoQixNQUFNLEVBQUUsR0FBRyxDQUFDLENBQVcsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBSyxDQUFDLENBQUM7SUFDL0UsT0FBTyxjQUFNLENBQUMsRUFBRSxFQUFFLEtBQUssQ0FBQyxDQUFDO0FBQzNCLENBQUM7QUFORCxrQkFNQztBQTZCRCxTQUFnQixLQUFLLENBQ25CLEdBQU0sRUFDTixLQUFtQixFQUNuQixLQUFnQjtJQUVoQixTQUFTLE1BQU0sQ0FBQyxFQUFlLEVBQUUsQ0FBVztRQUMxQyxPQUFPLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO0lBQ3hDLENBQUM7SUFJRCxTQUFTLFNBQVMsQ0FBQyxFQUFlLEVBQUUsWUFBdUI7UUFDekQsT0FBTyxZQUFZLEtBQUssU0FBUztZQUMvQixDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxZQUFZLENBQUM7WUFDMUIsQ0FBQyxDQUFDLENBQUMsaUJBQTJCLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztJQUNyRSxDQUFDO0lBRUQsT0FBTyxLQUFLLEtBQUssU0FBUztRQUN4QixDQUFDLENBQUMsU0FBUztRQUNYLENBQUMsQ0FBQyxLQUFLLEtBQUssU0FBUztZQUNuQixDQUFDLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQztZQUNsQixDQUFDLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQztBQUNoQyxDQUFDO0FBdEJELHNCQXNCQztBQThCRCxTQUFnQixTQUFTLENBQ3ZCLFFBQWlCLEVBQ2pCLEtBQW1CLEVBQ25CLEtBQWdCO0lBRWhCLFNBQVMsTUFBTSxDQUFDLEVBQWUsRUFBRSxDQUFXO1FBQzFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUMvQyxDQUFDO0lBSUQsU0FBUyxTQUFTLENBQUMsRUFBZSxFQUFFLFlBQXVCO1FBQ3pELE9BQU8sWUFBWSxLQUFLLFNBQVM7WUFDL0IsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsWUFBWSxDQUFDO1lBQzFCLENBQUMsQ0FBQyxDQUFDLGlCQUEyQixFQUFFLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLGlCQUFpQixDQUFDLENBQUM7SUFDckUsQ0FBQztJQUVELElBQUksS0FBSyxLQUFLLFNBQVMsRUFBRTtRQUN2QixPQUFPLFNBQVMsQ0FBQztLQUNsQjtTQUFNLElBQUksS0FBSyxLQUFLLFNBQVMsRUFBRTtRQUM5QixPQUFPLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztLQUN6QjtTQUFNO1FBQ0wsT0FBTyxTQUFTLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO0tBQ2hDO0FBQ0gsQ0FBQztBQXhCRCw4QkF3QkM7QUFzQ0QsU0FBZ0IsR0FBRyxDQUNqQixRQUFrQixFQUNsQixLQUFnQjtJQUVoQixNQUFNLEVBQUUsR0FBRyxDQUFDLENBQVcsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFLLENBQUMsQ0FBQztJQUNuRSxPQUFPLGNBQU0sQ0FBQyxFQUFFLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFDM0IsQ0FBQztBQU5ELGtCQU1DO0FBd0RELFNBQWdCLE9BQU8sQ0FDckIsTUFBMEIsRUFDMUIsS0FBZ0I7SUFFaEIsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFXLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUssQ0FBQyxDQUFDO0lBQzFFLE9BQU8sS0FBSyxLQUFLLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7QUFDOUMsQ0FBQztBQU5ELDBCQU1DO0FBRUQsdUNBQXVDO0FBQzFCLFFBQUEsS0FBSyxHQUFHLE9BQU8sQ0FBQztBQUU3Qix1Q0FBdUM7QUFDMUIsUUFBQSxPQUFPLEdBQUcsT0FBTyxDQUFDO0FBK0IvQixTQUFnQixFQUFFLENBQ2hCLFlBQXNCLEVBQ3RCLEtBQWdCO0lBRWhCLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBVyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUM1RCxPQUFPLEtBQUssS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO0FBQzlDLENBQUM7QUFORCxnQkFNQztBQW9CRCxTQUFnQixNQUFNLENBQ3BCLE1BQXNCLEVBQ3RCLEtBQWdCO0lBRWhCLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBVyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO0lBQ3hELE9BQU8sY0FBTSxDQUFDLEVBQUUsRUFBRSxLQUFLLENBQUMsQ0FBQztBQUMzQixDQUFDO0FBTkQsd0JBTUM7QUFFRDs7Ozs7Ozs7OztHQVVHO0FBQ0gsU0FBZ0IsY0FBYyxDQUFJLEtBQWU7SUFDL0MsT0FBTyxLQUFLLENBQUMsY0FBYyxFQUFFLENBQUM7QUFDaEMsQ0FBQztBQUZELHdDQUVDO0FBRUQsb0RBQW9EO0FBQ3ZDLFFBQUEsV0FBVyxHQUFHLGNBQWMsQ0FBQztBQUUxQyxvREFBb0Q7QUFDdkMsUUFBQSxTQUFTLEdBQUcsY0FBYyxDQUFDO0FBMEJ4QyxTQUFnQixRQUFRLENBQUksWUFBZSxFQUFFLEtBQWdCO0lBQzNELE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBVyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDbEUsT0FBTyxjQUFNLENBQUMsRUFBRSxFQUFFLEtBQUssQ0FBQyxDQUFDO0FBQzNCLENBQUM7QUFIRCw0QkFHQztBQUVELHdDQUF3QztBQUMzQixRQUFBLEtBQUssR0FBRyxRQUFRLENBQUM7QUFpQzlCLFNBQWdCLFlBQVksQ0FBSSxRQUFpQixFQUFFLEtBQWdCO0lBQ2pFLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBVyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztJQUNoRSxPQUFPLGNBQU0sQ0FBQyxFQUFFLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFDM0IsQ0FBQztBQUhELG9DQUdDO0FBRUQsZ0RBQWdEO0FBQ25DLFFBQUEsU0FBUyxHQUFHLFlBQVksQ0FBQztBQWdCdEMsU0FBZ0IsU0FBUyxDQUN2QixLQUFRLEVBQ1IsS0FBZ0I7SUFFaEIsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFXLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQyxXQUFFLENBQU8sQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxZQUFHLENBQU8sS0FBSyxDQUFDLENBQUMsQ0FBQztJQUNoRixPQUFPLEtBQUssS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO0FBQzlDLENBQUM7QUFORCw4QkFNQztBQWdCRCxTQUFnQixhQUFhLENBQzNCLE1BQWUsRUFDZixLQUFnQjtJQUVoQixNQUFNLEVBQUUsR0FBRyxDQUFDLENBQVcsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxDQUFDLFdBQUUsQ0FBTyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFlBQUcsQ0FBTyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDbkYsT0FBTyxjQUFNLENBQUMsRUFBRSxFQUFFLEtBQUssQ0FBQyxDQUFDO0FBQzNCLENBQUM7QUFORCxzQ0FNQztBQUVEOzs7Ozs7Ozs7Ozs7R0FZRztBQUNILFNBQWdCLFVBQVUsQ0FBSSxNQUFzQjtJQUNsRCxPQUFPLE1BQU0sQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFLLENBQUM7QUFDM0QsQ0FBQztBQUZELGdDQUVDO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQWtCRztBQUNILFNBQWdCLFFBQVEsQ0FBSSxLQUFlO0lBQ3pDLE1BQU0sSUFBSSxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztJQUNqRSxPQUFPLEdBQUcsS0FBSyxDQUFDLE9BQU8sR0FBRyxJQUFJLEVBQUUsQ0FBQztBQUNuQyxDQUFDO0FBSEQsNEJBR0M7QUE0REQsU0FBZ0IsS0FBSyxDQUFPLE9BQXNCLEVBQUUsS0FBZ0I7SUFDbEUsT0FBTyxLQUFLLEtBQUssU0FBUztRQUN4QixDQUFDLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUM7UUFDakQsQ0FBQyxDQUFDLENBQUMsWUFBc0IsRUFBRSxFQUFFLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLElBQUksRUFBRSxZQUFZLENBQUMsQ0FBQztBQUN6RixDQUFDO0FBSkQsc0JBSUM7QUFFRCxrQ0FBa0M7QUFDckIsUUFBQSxJQUFJLEdBQUcsS0FBSyxDQUFDO0FBc0IxQixTQUFnQixNQUFNLENBQUksRUFBWSxFQUFFLEVBQWE7SUFDbkQsT0FBTyxFQUFFLEtBQUssU0FBUztRQUNyQixDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQztZQUNQLElBQUksRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsSUFBSSxFQUFFLENBQUMsY0FBYyxFQUFFLEtBQUssSUFBSTtZQUN6RCxPQUFPLEVBQUUsR0FBRyxFQUFFLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQztTQUM3QixDQUFDO1FBQ0osQ0FBQyxDQUFDLENBQUMsTUFBZ0IsRUFBRSxFQUFFLENBQ25CLE1BQU0sQ0FBQyxLQUFLLENBQUM7WUFDWCxPQUFPLEVBQUUsR0FBRyxFQUFFLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQztZQUM1QixJQUFJLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsTUFBTSxFQUFFLElBQUksRUFBRSxDQUFDLGNBQWMsRUFBRSxLQUFLLElBQUk7U0FDMUQsQ0FBQyxDQUFDO0FBQ1gsQ0FBQztBQVhELHdCQVdDO0FBbUtELFNBQWdCLEVBQUUsQ0FDaEIsT0FBNkIsRUFDN0IsS0FBZ0I7SUFFaEIsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFXLEVBQUUsRUFBRSxDQUN6QixDQUFDLENBQUMsS0FBSyxDQUFDO1FBQ04sSUFBSSxFQUFFLEdBQUcsQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN2QyxPQUFPLEVBQUUsR0FBRyxFQUFFLENBQUMsYUFBSyxDQUFDLE9BQU8sRUFBSztLQUNsQyxDQUFDLENBQUM7SUFFTCxPQUFPLGNBQU0sQ0FBQyxFQUFFLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFDM0IsQ0FBQztBQVhELGdCQVdDO0FBRUQ7Ozs7R0FJRztBQUNILFNBQWdCLFVBQVUsQ0FBVSxJQUFTO0lBQzNDLE9BQU8sSUFBSSxZQUFZLElBQUksSUFBSSxJQUFJLFlBQVksT0FBTyxDQUFDO0FBQ3pELENBQUM7QUFGRCxnQ0FFQztBQThERCxTQUFnQixJQUFJLENBQ2xCLFNBQXVCLEVBQ3ZCLEtBQVc7SUFFWCxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQU0sRUFBRSxFQUFFLENBQUMsYUFBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7SUFDbkQsT0FBTyxjQUFNLENBQUMsRUFBRSxFQUFFLEtBQUssQ0FBQyxDQUFDO0FBQzNCLENBQUM7QUFORCxvQkFNQztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUNILFNBQWdCLElBQUksQ0FBSSxLQUFrQztJQUN4RCxPQUFPLGFBQUssQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDNUIsQ0FBQztBQUZELG9CQUVDO0FBRUQsNENBQTRDO0FBQy9CLFFBQUEsS0FBSyxHQUFHLElBQUksQ0FBQztBQUUxQjs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFDSCxTQUFnQixJQUFJLENBQUksS0FBa0M7SUFDeEQsT0FBTyxhQUFLLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDM0MsQ0FBQztBQUZELG9CQUVDO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0F5Qkc7QUFDSCxTQUFnQixHQUFHLENBQ2pCLEdBQUcsSUFBUztJQUVaLDBFQUEwRTtJQUMxRSxzRUFBc0U7SUFDdEUsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUNoQixDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQ3JFLGFBQUssQ0FBQyxJQUFJLENBQUMsRUFBUyxDQUFDLENBQ3RCLENBQUM7QUFDSixDQUFDO0FBVEQsa0JBU0M7QUE2Q0QsU0FBZ0IsS0FBSyxDQUNuQixNQUEwRDtJQUUxRCw0REFBNEQ7SUFDNUQsT0FBTyxHQUFHLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQztBQUN4QixDQUFDO0FBTEQsc0JBS0M7QUFJWSxRQUFBLEtBQUssR0FBRztJQUNuQixPQUFPO0lBQ1AsSUFBSTtJQUNKLE9BQU87SUFDUCxHQUFHO0lBQ0gsTUFBTTtJQUNOLFNBQVM7SUFDVCxJQUFJO0lBQ0osT0FBTztJQUNQLEVBQUU7SUFDRixJQUFJO0lBQ0osS0FBSyxFQUFMLGFBQUs7SUFDTCxZQUFZLEVBQVosb0JBQVk7SUFDWixJQUFJO0lBQ0osSUFBSTtJQUNKLEdBQUc7SUFDSCxLQUFLO0lBQ0wsU0FBUztJQUNULEdBQUc7SUFDSCxPQUFPO0lBQ1AsS0FBSyxFQUFMLGFBQUs7SUFDTCxPQUFPLEVBQVAsZUFBTztJQUNQLEVBQUU7SUFDRixNQUFNO0lBQ04sY0FBYztJQUNkLFdBQVcsRUFBWCxtQkFBVztJQUNYLFNBQVMsRUFBVCxpQkFBUztJQUNULFFBQVE7SUFDUixLQUFLLEVBQUwsYUFBSztJQUNMLFlBQVk7SUFDWixTQUFTLEVBQVQsaUJBQVM7SUFDVCxTQUFTO0lBQ1QsYUFBYTtJQUNiLFVBQVU7SUFDVixRQUFRO0lBQ1IsS0FBSztJQUNMLEtBQUs7SUFDTCxJQUFJLEVBQUosWUFBSTtJQUNKLE1BQU07SUFDTixFQUFFO0lBQ0YsVUFBVTtDQUNYLENBQUM7QUFFRixrQkFBZSxhQUFLLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiogW1tpbmNsdWRlOmRvYy9tYXliZS5tZF1dICovXG5cbi8qKiAoa2VlcCB0eXBlZG9jIGZyb20gZ2V0dGluZyBjb25mdXNlZCBieSB0aGUgaW1wb3J0cykgKi9cbmltcG9ydCBSZXN1bHQsIHsgZXJyLCBvayB9IGZyb20gJy4vcmVzdWx0JztcbmltcG9ydCB7IGN1cnJ5MSwgaXNWb2lkIH0gZnJvbSAnLi91dGlscyc7XG5cbi8qKlxuICBEaXNjcmltaW5hbnQgZm9yIHRoZSBgSnVzdGAgYW5kIGBOb3RoaW5nYCB2YXJpYW50cy5cblxuICBZb3UgY2FuIHVzZSB0aGUgZGlzY3JpbWluYW50IHZpYSB0aGUgYHZhcmlhbnRgIHByb3BlcnR5IG9mIGBNYXliZWAgaW5zdGFuY2VzXG4gIGlmIHlvdSBuZWVkIHRvIG1hdGNoIGV4cGxpY2l0bHkgb24gaXQuXG4gKi9cbmV4cG9ydCBlbnVtIFZhcmlhbnQge1xuICBKdXN0ID0gJ0p1c3QnLFxuICBOb3RoaW5nID0gJ05vdGhpbmcnLFxufVxuXG4vKiogU2ltcGx5IGRlZmluZXMgdGhlIGNvbW1vbiBzaGFwZSBmb3IgYEp1c3RgIGFuZCBgTm90aGluZ2AuICovXG5leHBvcnQgaW50ZXJmYWNlIE1heWJlU2hhcGU8VD4ge1xuICAvKiogRGlzdGluZ3Vpc2ggYmV0d2VlbiB0aGUgYEp1c3RgIGFuZCBgTm90aGluZ2AgW3ZhcmlhbnRzXSguLi9lbnVtcy9fbWF5YmVfLnZhcmlhbnQpLiAqL1xuICByZWFkb25seSB2YXJpYW50OiBWYXJpYW50O1xuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5pc0p1c3RgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNpc2p1c3QpICovXG4gIGlzSnVzdCh0aGlzOiBNYXliZTxUPik6IHRoaXMgaXMgSnVzdDxUPjtcblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUuaXNOb3RoaW5nYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjaXNub3RoaW5nKSAqL1xuICBpc05vdGhpbmcodGhpczogTWF5YmU8VD4pOiB0aGlzIGlzIE5vdGhpbmc8VD47XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLm1hcGBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI21hcCkgKi9cbiAgbWFwPFU+KHRoaXM6IE1heWJlPFQ+LCBtYXBGbjogKHQ6IFQpID0+IFUpOiBNYXliZTxVPjtcblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUubWFwT3JgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNtYXBvcikgKi9cbiAgbWFwT3I8VT4odGhpczogTWF5YmU8VD4sIG9yVTogVSwgbWFwRm46ICh0OiBUKSA9PiBVKTogVTtcblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUubWFwT3JFbHNlYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjbWFwb3JlbHNlKSAqL1xuICBtYXBPckVsc2U8VT4odGhpczogTWF5YmU8VD4sIG9yRWxzZUZuOiAoKSA9PiBVLCBtYXBGbjogKHQ6IFQpID0+IFUpOiBVO1xuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5tYXRjaGBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI21hdGNoKSAqL1xuICBtYXRjaDxVPih0aGlzOiBNYXliZTxUPiwgbWF0Y2hlcjogTWF0Y2hlcjxULCBVPik6IFU7XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLm9yYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjb3IpICovXG4gIG9yKHRoaXM6IE1heWJlPFQ+LCBtT3I6IE1heWJlPFQ+KTogTWF5YmU8VD47XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLm9yRWxzZWBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI29yZWxzZSkgKi9cbiAgb3JFbHNlKHRoaXM6IE1heWJlPFQ+LCBvckVsc2VGbjogKCkgPT4gTWF5YmU8VD4pOiBNYXliZTxUPjtcblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUuYW5kYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjYW5kKSAqL1xuICBhbmQ8VT4odGhpczogTWF5YmU8VD4sIG1BbmQ6IE1heWJlPFU+KTogTWF5YmU8VT47XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLmFuZFRoZW5gXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNhbmR0aGVuKSAqL1xuICBhbmRUaGVuPFU+KHRoaXM6IE1heWJlPFQ+LCBhbmRUaGVuRm46ICh0OiBUKSA9PiBNYXliZTxVPik6IE1heWJlPFU+O1xuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5jaGFpbmBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI2NoYWluKSAqL1xuICBjaGFpbjxVPih0aGlzOiBNYXliZTxUPiwgY2hhaW5GbjogKHQ6IFQpID0+IE1heWJlPFU+KTogTWF5YmU8VT47XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLmZsYXRNYXBgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNmbGF0bWFwKSAqL1xuICBmbGF0TWFwPFU+KHRoaXM6IE1heWJlPFQ+LCBmbGF0TWFwRm46ICh0OiBUKSA9PiBNYXliZTxVPik6IE1heWJlPFU+O1xuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS51bndyYXBgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCN1bndyYXApICovXG4gIHVuc2FmZWx5VW53cmFwKCk6IFQgfCBuZXZlcjtcblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUudW53cmFwT3JFbHNlYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjdW53cmFwb3JlbHNlKSAqL1xuICB1bndyYXBPckVsc2UodGhpczogTWF5YmU8VD4sIGVsc2VGbjogKCkgPT4gVCk6IFQ7XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLnRvT2tPckVycmBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI3Rvb2tvcmVycikgKi9cbiAgdG9Pa09yRXJyPEU+KHRoaXM6IE1heWJlPFQ+LCBlcnJvcjogRSk6IFJlc3VsdDxULCBFPjtcblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUudG9Pa09yRWxzZUVycmBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI3Rvb2tvcmVsc2VlcnIpICovXG4gIHRvT2tPckVsc2VFcnI8RT4odGhpczogTWF5YmU8VD4sIGVsc2VGbjogKCkgPT4gRSk6IFJlc3VsdDxULCBFPjtcblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUudG9TdHJpbmdgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCN0b3N0cmluZykgKi9cbiAgdG9TdHJpbmcodGhpczogTWF5YmU8VD4pOiBzdHJpbmc7XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLmVxdWFsc2BdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI2VxdWFscykgKi9cbiAgZXF1YWxzKHRoaXM6IE1heWJlPFQ+LCBjb21wYXJpc29uOiBNYXliZTxUPik6IGJvb2xlYW47XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLmFwYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjYXApICovXG4gIGFwPFU+KHRoaXM6IE1heWJlPCh2YWw6IFQpID0+IFU+LCB2YWw6IE1heWJlPFQ+KTogTWF5YmU8VT47XG59XG5cbi8qKlxuICBBIGBKdXN0YCBpbnN0YW5jZSBpcyB0aGUgKnByZXNlbnQqIHZhcmlhbnQgaW5zdGFuY2Ugb2YgdGhlXG4gIFtgTWF5YmVgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNtYXliZSkgdHlwZSwgcmVwcmVzZW50aW5nIHRoZSBwcmVzZW5jZSBvZiBhXG4gIHZhbHVlIHdoaWNoIG1heSBiZSBhYnNlbnQuIEZvciBhIGZ1bGwgZGlzY3Vzc2lvbiwgc2VlIFt0aGUgbW9kdWxlXG4gIGRvY3NdKC4uL21vZHVsZXMvX21heWJlXy5odG1sKS5cblxuICBAdHlwZXBhcmFtIFQgVGhlIHR5cGUgd3JhcHBlZCBpbiB0aGlzIGBKdXN0YCB2YXJpYW50IG9mIGBNYXliZWAuXG4gKi9cbmV4cG9ydCBjbGFzcyBKdXN0PFQ+IGltcGxlbWVudHMgTWF5YmVTaGFwZTxUPiB7XG4gIC8qKlxuICAgIFVud3JhcCB0aGUgY29udGFpbmVkIHZhbHVlLiBBIGNvbnZlbmllbmNlIG1ldGhvZCBmb3IgZnVuY3Rpb25hbCBpZGlvbXMuXG5cbiAgICBBIGNvbW1vbiBzY2VuYXJpbyB3aGVyZSB5b3UgbWlnaHQgd2FudCB0byB1c2UgdGhpcyBpcyBpbiBhIHBpcGVsaW5lIG9mXG4gICAgZnVuY3Rpb25zOlxuXG4gICAgYGBgdHNcbiAgICBpbXBvcnQgTWF5YmUsIHsgSnVzdCB9IGZyb20gJ3RydWUtbXl0aC9tYXliZSc7XG5cbiAgICBmdW5jdGlvbiBnZXRMZW5ndGhzKG1heWJlU3RyaW5nczogQXJyYXk8TWF5YmU8c3RyaW5nPj4pOiBBcnJheTxudW1iZXI+IHtcbiAgICAgIHJldHVybiBtYXliZVN0cmluZ3NcbiAgICAgICAgLmZpbHRlcihNYXliZS5pc0p1c3QpXG4gICAgICAgIC5tYXAoSnVzdC51bndyYXApXG4gICAgICAgIC5tYXAocyA9PiBzLmxlbmd0aCk7XG4gICAgfVxuICAgIGBgYFxuICAgKi9cbiAgc3RhdGljIHVud3JhcDxKPih0aGVKdXN0OiBKdXN0PEo+KTogSiB7XG4gICAgcmV0dXJuIHRoZUp1c3QudmFsdWU7XG4gIH1cblxuICAvKiogYEp1c3RgIGlzIGFsd2F5cyBbYFZhcmlhbnQuSnVzdGBdKC4uL2VudW1zL19tYXliZV8udmFyaWFudCNqdXN0KS4gKi9cbiAgcmVhZG9ubHkgdmFyaWFudDogVmFyaWFudC5KdXN0ID0gVmFyaWFudC5KdXN0O1xuXG4gIC8qKiBUaGUgd3JhcHBlZCB2YWx1ZS4gKi9cbiAgcmVhZG9ubHkgdmFsdWU6IFQ7XG5cbiAgLyoqXG4gICAgQ3JlYXRlIGFuIGluc3RhbmNlIG9mIGBNYXliZS5KdXN0YCB3aXRoIGBuZXdgLlxuXG4gICAgQG5vdGUgV2hpbGUgeW91ICptYXkqIGNyZWF0ZSB0aGUgYEp1c3RgIHR5cGUgdmlhIG5vcm1hbCBKYXZhU2NyaXB0XG4gICAgY2xhc3MgY29uc3RydWN0aW9uLCBpdCBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHRoZSBmdW5jdGlvbmFsIHN0eWxlIGZvclxuICAgIHdoaWNoIHRoZSBsaWJyYXJ5IGlzIGludGVuZGVkLiBJbnN0ZWFkLCB1c2UgW2BNYXliZS5vZmBdIChmb3IgdGhlIGdlbmVyYWxcbiAgICBjYXNlKSBvciBbYE1heWJlLmp1c3RgXSBmb3IgdGhpcyBzcGVjaWZpYyBjYXNlLlxuXG4gICAgW2BNYXliZS5vZmBdOiAuLi9tb2R1bGVzL19tYXliZV8uaHRtbCNvZlxuICAgIFtgTWF5YmUuanVzdGBdOiAuLi9tb2R1bGVzL19tYXliZV8uaHRtbCNqdXN0XG5cbiAgICBgYGB0c1xuICAgIC8vIEF2b2lkOlxuICAgIGNvbnN0IGFTdHJpbmcgPSBuZXcgTWF5YmUuSnVzdCgnY2hhcmFjdGVycycpO1xuXG4gICAgLy8gUHJlZmVyOlxuICAgIGNvbnN0IGFTdHJpbmcgPSBNYXliZS5qdXN0KCdjaGFyYWN0ZXJzKTtcbiAgICBgYGBcblxuICAgIEBwYXJhbSB2YWx1ZVxuICAgIFRoZSB2YWx1ZSB0byB3cmFwIGluIGEgYE1heWJlLkp1c3RgLlxuXG4gICAgYG51bGxgIGFuZCBgdW5kZWZpbmVkYCBhcmUgYWxsb3dlZCBieSB0aGUgdHlwZSBzaWduYXR1cmUgc28gdGhhdCB0aGVcbiAgICBjb25zdHJ1Y3RvciBtYXkgYHRocm93YCBvbiB0aG9zZSByYXRoZXIgdGhhbiBjb25zdHJ1Y3RpbmcgYSB0eXBlIGxpa2VcbiAgICBgTWF5YmU8dW5kZWZpbmVkPmAuXG5cbiAgICBAdGhyb3dzICAgICAgSWYgeW91IHBhc3MgYG51bGxgIG9yIGB1bmRlZmluZWRgLlxuICAgKi9cbiAgY29uc3RydWN0b3IodmFsdWU/OiBUIHwgbnVsbCkge1xuICAgIGlmIChpc1ZvaWQodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyaWVkIHRvIGNvbnN0cnVjdCBgSnVzdGAgd2l0aCBgbnVsbGAgb3IgYHVuZGVmaW5lZGAnKTtcbiAgICB9XG5cbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUuaXNKdXN0YF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjaXNqdXN0KSAqL1xuICBpc0p1c3QodGhpczogTWF5YmU8VD4pOiB0aGlzIGlzIEp1c3Q8VD4ge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLmlzTm90aGluZ2BdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI2lzbm90aGluZykgKi9cbiAgaXNOb3RoaW5nKHRoaXM6IE1heWJlPFQ+KTogdGhpcyBpcyBOb3RoaW5nPFQ+IHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUubWFwYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjbWFwKSAqL1xuICBtYXA8VT4odGhpczogTWF5YmU8VD4sIG1hcEZuOiAodDogVCkgPT4gVSk6IE1heWJlPFU+IHtcbiAgICByZXR1cm4gbWFwKG1hcEZuLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5tYXBPcmBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI21hcG9yKSAqL1xuICBtYXBPcjxVPih0aGlzOiBNYXliZTxUPiwgb3JVOiBVLCBtYXBGbjogKHQ6IFQpID0+IFUpOiBVIHtcbiAgICByZXR1cm4gbWFwT3Iob3JVLCBtYXBGbiwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUubWFwT3JFbHNlYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjbWFwb3JlbHNlKSAqL1xuICBtYXBPckVsc2U8VT4odGhpczogTWF5YmU8VD4sIG9yRWxzZUZuOiAoKSA9PiBVLCBtYXBGbjogKHQ6IFQpID0+IFUpOiBVIHtcbiAgICByZXR1cm4gbWFwT3JFbHNlKG9yRWxzZUZuLCBtYXBGbiwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUubWF0Y2hgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNtYXRjaCkgKi9cbiAgbWF0Y2g8VT4odGhpczogTWF5YmU8VD4sIG1hdGNoZXI6IE1hdGNoZXI8VCwgVT4pOiBVIHtcbiAgICByZXR1cm4gbWF0Y2gobWF0Y2hlciwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUub3JgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNvcikgKi9cbiAgb3IodGhpczogTWF5YmU8VD4sIG1PcjogTWF5YmU8VD4pOiBNYXliZTxUPiB7XG4gICAgcmV0dXJuIG9yKG1PciwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUub3JFbHNlYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjb3JlbHNlKSAqL1xuICBvckVsc2UodGhpczogTWF5YmU8VD4sIG9yRWxzZUZuOiAoKSA9PiBNYXliZTxUPik6IE1heWJlPFQ+IHtcbiAgICByZXR1cm4gb3JFbHNlKG9yRWxzZUZuLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5hbmRgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNhbmQpICovXG4gIGFuZDxVPih0aGlzOiBNYXliZTxUPiwgbUFuZDogTWF5YmU8VT4pOiBNYXliZTxVPiB7XG4gICAgcmV0dXJuIGFuZChtQW5kLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5hbmRUaGVuYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjYW5kdGhlbikgKi9cbiAgYW5kVGhlbjxVPih0aGlzOiBNYXliZTxUPiwgYW5kVGhlbkZuOiAodDogVCkgPT4gTWF5YmU8VT4pOiBNYXliZTxVPiB7XG4gICAgcmV0dXJuIGFuZFRoZW4oYW5kVGhlbkZuLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5jaGFpbmBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI2NoYWluKSAqL1xuICBjaGFpbjxVPih0aGlzOiBNYXliZTxUPiwgY2hhaW5GbjogKHQ6IFQpID0+IE1heWJlPFU+KTogTWF5YmU8VT4ge1xuICAgIHJldHVybiB0aGlzLmFuZFRoZW4oY2hhaW5Gbik7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUuZmxhdE1hcGBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI2ZsYXRtYXApICovXG4gIGZsYXRNYXA8VT4odGhpczogTWF5YmU8VD4sIGZsYXRNYXBGbjogKHQ6IFQpID0+IE1heWJlPFU+KTogTWF5YmU8VT4ge1xuICAgIHJldHVybiB0aGlzLmFuZFRoZW4oZmxhdE1hcEZuKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS51bnNhZmVseVVud3JhcGBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI3Vuc2FmZWx5dW53cmFwKSAqL1xuICB1bnNhZmVseVVud3JhcCgpOiBUIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS51bndyYXBPcmBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI3Vud3JhcG9yKSAqL1xuICB1bndyYXBPcih0aGlzOiBNYXliZTxUPiwgZGVmYXVsdFZhbHVlOiBUKTogVCB7XG4gICAgcmV0dXJuIHVud3JhcE9yKGRlZmF1bHRWYWx1ZSwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUudW53cmFwT3JFbHNlYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjdW53cmFwb3JlbHNlKSAqL1xuICB1bndyYXBPckVsc2UodGhpczogTWF5YmU8VD4sIGVsc2VGbjogKCkgPT4gVCk6IFQge1xuICAgIHJldHVybiB1bndyYXBPckVsc2UoZWxzZUZuLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS50b09rT3JFcnJgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCN0b29rb3JlcnIpICovXG4gIHRvT2tPckVycjxFPih0aGlzOiBNYXliZTxUPiwgZXJyb3I6IEUpOiBSZXN1bHQ8VCwgRT4ge1xuICAgIHJldHVybiB0b09rT3JFcnIoZXJyb3IsIHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLnRvT2tPckVsc2VFcnJgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCN0b29rb3JlbHNlZXJyKSAqL1xuICB0b09rT3JFbHNlRXJyPEU+KHRoaXM6IE1heWJlPFQ+LCBlbHNlRm46ICgpID0+IEUpOiBSZXN1bHQ8VCwgRT4ge1xuICAgIHJldHVybiB0b09rT3JFbHNlRXJyKGVsc2VGbiwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUudG9TdHJpbmdgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCN0b3N0cmluZykgKi9cbiAgdG9TdHJpbmcodGhpczogTWF5YmU8VD4pOiBzdHJpbmcge1xuICAgIHJldHVybiB0b1N0cmluZyh0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5lcXVhbHNgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNlcXVhbHMpICovXG4gIGVxdWFscyh0aGlzOiBNYXliZTxUPiwgY29tcGFyaXNvbjogTWF5YmU8VD4pOiBib29sZWFuIHtcbiAgICByZXR1cm4gZXF1YWxzKGNvbXBhcmlzb24sIHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLmFwYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjYXApICovXG4gIGFwPEEsIEI+KHRoaXM6IE1heWJlPCh2YWw6IEEpID0+IEI+LCB2YWw6IE1heWJlPEE+KTogTWF5YmU8Qj4ge1xuICAgIHJldHVybiBhcCh0aGlzLCB2YWwpO1xuICB9XG59XG5cbi8qKlxuICBBIGBOb3RoaW5nYCBpbnN0YW5jZSBpcyB0aGUgKmFic2VudCogdmFyaWFudCBpbnN0YW5jZSBvZiB0aGVcbiAgW2BNYXliZWBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI21heWJlKSB0eXBlLCByZXByZXNlbnRpbmcgdGhlIHByZXNlbmNlIG9mIGFcbiAgdmFsdWUgd2hpY2ggbWF5IGJlIGFic2VudC4gRm9yIGEgZnVsbCBkaXNjdXNzaW9uLCBzZWUgW3RoZSBtb2R1bGVcbiAgZG9jc10oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwpLlxuXG4gIEB0eXBlcGFyYW0gVCBUaGUgdHlwZSB3aGljaCB3b3VsZCBiZSB3cmFwcGVkIGluIGEgYEp1c3RgIHZhcmlhbnQgb2YgYE1heWJlYC5cbiAqL1xuZXhwb3J0IGNsYXNzIE5vdGhpbmc8VD4gaW1wbGVtZW50cyBNYXliZVNoYXBlPFQ+IHtcbiAgLyoqIGBOb3RoaW5nYCBpcyBhbHdheXMgW2BWYXJpYW50Lk5vdGhpbmdgXSguLi9lbnVtcy9fbWF5YmVfLnZhcmlhbnQjbm90aGluZykuICovXG4gIHJlYWRvbmx5IHZhcmlhbnQ6IFZhcmlhbnQuTm90aGluZyA9IFZhcmlhbnQuTm90aGluZztcblxuICAvKipcbiAgICBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgYE1heWJlLk5vdGhpbmdgIHdpdGggYG5ld2AuXG5cbiAgICBAbm90ZSBXaGlsZSB5b3UgKm1heSogY3JlYXRlIHRoZSBgTm90aGluZ2AgdHlwZSB2aWEgbm9ybWFsIEphdmFTY3JpcHRcbiAgICBjbGFzcyBjb25zdHJ1Y3Rpb24sIGl0IGlzIG5vdCByZWNvbW1lbmRlZCBmb3IgdGhlIGZ1bmN0aW9uYWwgc3R5bGUgZm9yXG4gICAgd2hpY2ggdGhlIGxpYnJhcnkgaXMgaW50ZW5kZWQuIEluc3RlYWQsIHVzZSBbYE1heWJlLm9mYF0gKGZvciB0aGUgZ2VuZXJhbFxuICAgIGNhc2UpIG9yIFtgTWF5YmUubm90aGluZ2BdIGZvciB0aGlzIHNwZWNpZmljIGNhc2UuXG5cbiAgICBbYE1heWJlLm9mYF06IC4uL21vZHVsZXMvX21heWJlXy5odG1sI29mXG4gICAgW2BNYXliZS5ub3RoaW5nYF06IC4uL21vZHVsZXMvX21heWJlXy5odG1sI25vdGhpbmdcblxuICAgIGBgYHRzXG4gICAgLy8gQXZvaWQ6XG4gICAgY29uc3QgYU5vdGhpbmcgPSBuZXcgTWF5YmUuRXJyKCk7XG5cbiAgICAvLyBQcmVmZXI6XG4gICAgY29uc3QgYU5vdGhpbmcgPSBNYXliZS5ub3RoaW5nKCk7XG4gICAgYGBgXG5cbiAgICBgbnVsbGAgYW5kIGB1bmRlZmluZWRgIGFyZSBhbGxvd2VkIHNvIHRoYXQgeW91IG1heSBleHBsaWNpdGx5IGNvbnN0cnVjdCB0aGVcbiAgICBgRXJyYCB0eXBlIHdpdGggYSBrbm93biBgbnVsbGAgb3IgYHVuZGVmaW5lZGAgdmFsdWUuIChUaGlzIG1heWJlIGhlbHBmdWxcbiAgICBwcmltYXJpbHkgd2hlbiB0cmFuc2l0aW9uaW5nIGEgY29kZWJhc2UgdG8gdGhlIHVzZSBvZiBgTWF5YmVgLilcblxuICAgIEB0aHJvd3MgICAgICBJZiB5b3UgcGFzcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihfPzogbnVsbCkge1xuICAgIC8qIG5vdGhpbmcgdG8gZG8gKi9cbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5pc0p1c3RgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNpc2p1c3QpICovXG4gIGlzSnVzdCh0aGlzOiBNYXliZTxUPik6IHRoaXMgaXMgSnVzdDxUPiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLmlzTm90aGluZ2BdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI2lzbm90aGluZykgKi9cbiAgaXNOb3RoaW5nKHRoaXM6IE1heWJlPFQ+KTogdGhpcyBpcyBOb3RoaW5nPFQ+IHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5tYXBgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNtYXApICovXG4gIG1hcDxVPih0aGlzOiBNYXliZTxUPiwgbWFwRm46ICh0OiBUKSA9PiBVKTogTWF5YmU8VT4ge1xuICAgIHJldHVybiBtYXAobWFwRm4sIHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLm1hcE9yYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjbWFwb3IpICovXG4gIG1hcE9yPFU+KHRoaXM6IE1heWJlPFQ+LCBvclU6IFUsIG1hcEZuOiAodDogVCkgPT4gVSk6IFUge1xuICAgIHJldHVybiBtYXBPcihvclUsIG1hcEZuLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5tYXBPckVsc2VgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNtYXBvcmVsc2UpICovXG4gIG1hcE9yRWxzZTxVPih0aGlzOiBNYXliZTxUPiwgb3JFbHNlRm46ICgpID0+IFUsIG1hcEZuOiAodDogVCkgPT4gVSk6IFUge1xuICAgIHJldHVybiBtYXBPckVsc2Uob3JFbHNlRm4sIG1hcEZuLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5tYXRjaGBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI21hdGNoKSAqL1xuICBtYXRjaDxVPih0aGlzOiBNYXliZTxUPiwgbWF0Y2hlcjogTWF0Y2hlcjxULCBVPik6IFUge1xuICAgIHJldHVybiBtYXRjaChtYXRjaGVyLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5vcmBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI29yKSAqL1xuICBvcih0aGlzOiBNYXliZTxUPiwgbU9yOiBNYXliZTxUPik6IE1heWJlPFQ+IHtcbiAgICByZXR1cm4gb3IobU9yLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5vckVsc2VgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNvcmVsc2UpICovXG4gIG9yRWxzZSh0aGlzOiBNYXliZTxUPiwgb3JFbHNlRm46ICgpID0+IE1heWJlPFQ+KTogTWF5YmU8VD4ge1xuICAgIHJldHVybiBvckVsc2Uob3JFbHNlRm4sIHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLmFuZGBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI2FuZCkgKi9cbiAgYW5kPFU+KHRoaXM6IE1heWJlPFQ+LCBtQW5kOiBNYXliZTxVPik6IE1heWJlPFU+IHtcbiAgICByZXR1cm4gYW5kKG1BbmQsIHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLmFuZFRoZW5gXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNhbmR0aGVuKSAqL1xuICBhbmRUaGVuPFU+KHRoaXM6IE1heWJlPFQ+LCBhbmRUaGVuRm46ICh0OiBUKSA9PiBNYXliZTxVPik6IE1heWJlPFU+IHtcbiAgICByZXR1cm4gYW5kVGhlbihhbmRUaGVuRm4sIHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLmNoYWluYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjY2hhaW4pICovXG4gIGNoYWluPFU+KHRoaXM6IE1heWJlPFQ+LCBjaGFpbkZuOiAodDogVCkgPT4gTWF5YmU8VT4pOiBNYXliZTxVPiB7XG4gICAgcmV0dXJuIHRoaXMuYW5kVGhlbihjaGFpbkZuKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5mbGF0TWFwYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjZmxhdG1hcCkgKi9cbiAgZmxhdE1hcDxVPih0aGlzOiBNYXliZTxUPiwgZmxhdE1hcEZuOiAodDogVCkgPT4gTWF5YmU8VT4pOiBNYXliZTxVPiB7XG4gICAgcmV0dXJuIHRoaXMuYW5kVGhlbihmbGF0TWFwRm4pO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLnVuc2FmZWx5VW53cmFwYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjdW5zYWZlbHl1bndyYXApICovXG4gIHVuc2FmZWx5VW53cmFwKCk6IG5ldmVyIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyaWVkIHRvIGB1bnNhZmVseVVud3JhcChOb3RoaW5nKWAnKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS51bndyYXBPcmBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI3Vud3JhcG9yKSAqL1xuICB1bndyYXBPcih0aGlzOiBNYXliZTxUPiwgZGVmYXVsdFZhbHVlOiBUKTogVCB7XG4gICAgcmV0dXJuIHVud3JhcE9yKGRlZmF1bHRWYWx1ZSwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUudW53cmFwT3JFbHNlYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjdW53cmFwb3JlbHNlKSAqL1xuICB1bndyYXBPckVsc2UodGhpczogTWF5YmU8VD4sIGVsc2VGbjogKCkgPT4gVCk6IFQge1xuICAgIHJldHVybiB1bndyYXBPckVsc2UoZWxzZUZuLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS50b09rT3JFcnJgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCN0b29rb3JlcnIpICovXG4gIHRvT2tPckVycjxFPih0aGlzOiBNYXliZTxUPiwgZXJyb3I6IEUpOiBSZXN1bHQ8VCwgRT4ge1xuICAgIHJldHVybiB0b09rT3JFcnIoZXJyb3IsIHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLnRvT2tPckVsc2VFcnJgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCN0b29rb3JlbHNlZXJyKSAqL1xuICB0b09rT3JFbHNlRXJyPEU+KHRoaXM6IE1heWJlPFQ+LCBlbHNlRm46ICgpID0+IEUpOiBSZXN1bHQ8VCwgRT4ge1xuICAgIHJldHVybiB0b09rT3JFbHNlRXJyKGVsc2VGbiwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUudG9TdHJpbmdgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCN0b3N0cmluZykgKi9cbiAgdG9TdHJpbmcodGhpczogTWF5YmU8VD4pOiBzdHJpbmcge1xuICAgIHJldHVybiB0b1N0cmluZyh0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5lcXVhbHNgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNlcXVhbHMpICovXG4gIGVxdWFscyh0aGlzOiBNYXliZTxUPiwgY29tcGFyaXNvbjogTWF5YmU8VD4pOiBib29sZWFuIHtcbiAgICByZXR1cm4gZXF1YWxzKGNvbXBhcmlzb24sIHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLmFwYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjYXApICovXG4gIGFwPEEsIEI+KHRoaXM6IE1heWJlPCh2YWw6IEEpID0+IEI+LCB2YWw6IE1heWJlPEE+KTogTWF5YmU8Qj4ge1xuICAgIHJldHVybiBhcCh0aGlzLCB2YWwpO1xuICB9XG59XG5cbi8qKlxuICBJcyB0aGlzIHJlc3VsdCBhIGBKdXN0YCBpbnN0YW5jZT9cblxuICBAdHlwZXBhcmFtIFQgVGhlIHR5cGUgb2YgdGhlIHdyYXBwZWQgdmFsdWUuXG4gIEBwYXJhbSBtYXliZSBUaGUgYE1heWJlYCBpbnN0YW5jZSB0byBjaGVjay5cbiAgQHJldHVybnMgICAgIGB0cnVlYCBpZiBgbWF5YmVgIGlzIGBKdXN0YCwgYGZhbHNlYCBvdGhlcndpc2UuIEluIFR5cGVTY3JpcHQsXG4gICAgICAgICAgICAgICBhbHNvIG5hcnJvd3MgdGhlIHR5cGUgZnJvbSBgTWF5YmU8VD5gIHRvIGBKdXN0PFQ+YC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSnVzdDxUPihtYXliZTogTWF5YmU8VD4pOiBtYXliZSBpcyBKdXN0PFQ+IHtcbiAgcmV0dXJuIG1heWJlLnZhcmlhbnQgPT09IFZhcmlhbnQuSnVzdDtcbn1cblxuLyoqXG4gIElzIHRoaXMgcmVzdWx0IGEgYE5vdGhpbmdgIGluc3RhbmNlP1xuXG4gIEB0eXBlcGFyYW0gVCBUaGUgdHlwZSBvZiB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgQHBhcmFtIG1heWJlIFRoZSBgTWF5YmVgIGluc3RhbmNlIHRvIGNoZWNrLlxuICBAcmV0dXJucyAgICAgYHRydWVgIGlmIGBtYXliZWAgaXMgYG5vdGhpbmdgLCBgZmFsc2VgIG90aGVyd2lzZS4gSW4gVHlwZVNjcmlwdCxcbiAgICAgICAgICAgICAgIGFsc28gbmFycm93cyB0aGUgdHlwZSBmcm9tIGBNYXliZTxUPmAgdG8gYE5vdGhpbmc8VD5gLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNOb3RoaW5nPFQ+KG1heWJlOiBNYXliZTxUPik6IG1heWJlIGlzIE5vdGhpbmc8VD4ge1xuICByZXR1cm4gbWF5YmUudmFyaWFudCA9PT0gVmFyaWFudC5Ob3RoaW5nO1xufVxuXG4vKipcbiAgQ3JlYXRlIGFuIGluc3RhbmNlIG9mIGBNYXliZS5KdXN0YC5cblxuICBgbnVsbGAgYW5kIGB1bmRlZmluZWRgIGFyZSBhbGxvd2VkIGJ5IHRoZSB0eXBlIHNpZ25hdHVyZSBzbyB0aGF0IHRoZVxuICBmdW5jdGlvbiBtYXkgYHRocm93YCBvbiB0aG9zZSByYXRoZXIgdGhhbiBjb25zdHJ1Y3RpbmcgYSB0eXBlIGxpa2VcbiAgYE1heWJlPHVuZGVmaW5lZD5gLlxuXG4gIEB0eXBlcGFyYW0gVCBUaGUgdHlwZSBvZiB0aGUgaXRlbSBjb250YWluZWQgaW4gdGhlIGBNYXliZWAuXG4gIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcCBpbiBhIGBNYXliZS5KdXN0YC5cbiAgQHJldHVybnMgICAgIEFuIGluc3RhbmNlIG9mIGBNYXliZS5KdXN0PFQ+YC5cbiAgQHRocm93cyAgICAgIElmIHlvdSBwYXNzIGBudWxsYCBvciBgdW5kZWZpbmVkYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGp1c3Q8VD4odmFsdWU/OiBUIHwgbnVsbCk6IE1heWJlPFQ+IHtcbiAgcmV0dXJuIG5ldyBKdXN0PFQ+KHZhbHVlKTtcbn1cblxuLyoqXG4gIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBgTWF5YmUuTm90aGluZ2AuXG5cbiAgSWYgeW91IHdhbnQgdG8gY3JlYXRlIGFuIGluc3RhbmNlIHdpdGggYSBzcGVjaWZpYyB0eXBlLCBlLmcuIGZvciB1c2UgaW4gYVxuICBmdW5jdGlvbiB3aGljaCBleHBlY3RzIGEgYE1heWJlPFQ+YCB3aGVyZSB0aGUgYDxUPmAgaXMga25vd24gYnV0IHlvdSBoYXZlIG5vXG4gIHZhbHVlIHRvIGdpdmUgaXQsIHlvdSBjYW4gdXNlIGEgdHlwZSBwYXJhbWV0ZXI6XG5cbiAgYGBgdHNcbiAgY29uc3Qgbm90U3RyaW5nID0gTWF5YmUubm90aGluZzxzdHJpbmc+KCk7XG4gIGBgYFxuXG4gIEB0eXBlcGFyYW0gVCBUaGUgdHlwZSBvZiB0aGUgaXRlbSBjb250YWluZWQgaW4gdGhlIGBNYXliZWAuXG4gIEByZXR1cm5zICAgICBBbiBpbnN0YW5jZSBvZiBgTWF5YmUuTm90aGluZzxUPmAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3RoaW5nPFQ+KF8/OiBudWxsKTogTWF5YmU8VD4ge1xuICByZXR1cm4gbmV3IE5vdGhpbmc8VD4oXyk7XG59XG5cbi8qKlxuICBDcmVhdGUgYSBgTWF5YmVgIGZyb20gYW55IHZhbHVlLlxuXG4gIFRvIHNwZWNpZnkgdGhhdCB0aGUgcmVzdWx0IHNob3VsZCBiZSBpbnRlcnByZXRlZCBhcyBhIHNwZWNpZmljIHR5cGUsIHlvdSBtYXlcbiAgaW52b2tlIGBNYXliZS5vZmAgd2l0aCBhbiBleHBsaWNpdCB0eXBlIHBhcmFtZXRlcjpcblxuICBgYGB0c1xuICBjb25zdCBmb28gPSBNYXliZS5vZjxzdHJpbmc+KG51bGwpO1xuICBgYGBcblxuICBUaGlzIGlzIHVzdWFsbHkgb25seSBpbXBvcnRhbnQgaW4gdHdvIGNhc2VzOlxuXG4gIDEuICBJZiB5b3UgYXJlIGludGVudGlvbmFsbHkgY29uc3RydWN0aW5nIGEgYE5vdGhpbmdgIGZyb20gYSBrbm93biBgbnVsbGAgb3JcbiAgICAgIHVuZGVmaW5lZCB2YWx1ZSAqd2hpY2ggaXMgdW50eXBlZCouXG4gIDIuICBJZiB5b3UgYXJlIHNwZWNpZnlpbmcgdGhhdCB0aGUgdHlwZSBpcyBtb3JlIGdlbmVyYWwgdGhhbiB0aGUgdmFsdWUgcGFzc2VkXG4gICAgICAoc2luY2UgVHlwZVNjcmlwdCBjYW4gZGVmaW5lIHR5cGVzIGFzIGxpdGVyYWxzKS5cblxuICBAdHlwZXBhcmFtIFQgVGhlIHR5cGUgb2YgdGhlIGl0ZW0gY29udGFpbmVkIGluIHRoZSBgTWF5YmVgLlxuICBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAgaW4gYSBgTWF5YmVgLiBJZiBpdCBpcyBgdW5kZWZpbmVkYCBvciBgbnVsbGAsXG4gICAgICAgICAgICAgICB0aGUgcmVzdWx0IHdpbGwgYmUgYE5vdGhpbmdgOyBvdGhlcndpc2UgaXQgd2lsbCBiZSB0aGUgdHlwZSBvZlxuICAgICAgICAgICAgICAgdGhlIHZhbHVlIHBhc3NlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9mPFQ+KHZhbHVlPzogVCB8IG51bGwpOiBNYXliZTxUPiB7XG4gIHJldHVybiBpc1ZvaWQodmFsdWUpID8gbm90aGluZzxUPigpIDoganVzdCh2YWx1ZSk7XG59XG5cbi8qKiBBbGlhcyBmb3IgW2BvZmBdKCNvZiksIHByaW1hcmlseSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIEZvbGt0YWxlLiAqL1xuZXhwb3J0IGNvbnN0IGZyb21OdWxsYWJsZSA9IG9mO1xuXG4vKipcbiAgTWFwIG92ZXIgYSBgTWF5YmVgIGluc3RhbmNlOiBhcHBseSB0aGUgZnVuY3Rpb24gdG8gdGhlIHdyYXBwZWQgdmFsdWUgaWYgdGhlXG4gIGluc3RhbmNlIGlzIGBKdXN0YCwgYW5kIHJldHVybiBgTm90aGluZ2AgaWYgdGhlIGluc3RhbmNlIGlzIGBOb3RoaW5nYC5cblxuICBgTWF5YmUubWFwYCB3b3JrcyBhIGxvdCBsaWtlIGBBcnJheS5wcm90b3R5cGUubWFwYDogYE1heWJlYCBhbmQgYEFycmF5YCBhcmVcbiAgYm90aCAqY29udGFpbmVycyogZm9yIG90aGVyIHRoaW5ncy4gSWYgeW91IGhhdmUgbm8gaXRlbXMgaW4gYW4gYXJyYXkgb2ZcbiAgbnVtYmVycyBuYW1lZCBgZm9vYCBhbmQgY2FsbCBgZm9vLm1hcCh4ID0+IHggKyAxKWAsIHlvdSdsbCBzdGlsbCBqdXN0IGhhdmUgYW5cbiAgYXJyYXkgd2l0aCBub3RoaW5nIGluIGl0LiBCdXQgaWYgeW91IGhhdmUgYW55IGl0ZW1zIGluIHRoZSBhcnJheSAoYFsyLCAzXWApLFxuICBhbmQgeW91IGNhbGwgYGZvby5tYXAoeCA9PiB4ICsgMSlgIG9uIGl0LCB5b3UnbGwgZ2V0IGEgbmV3IGFycmF5IHdpdGggZWFjaCBvZlxuICB0aG9zZSBpdGVtcyBpbnNpZGUgdGhlIGFycmF5IFwiY29udGFpbmVyXCIgdHJhbnNmb3JtZWQgKGBbMywgNF1gKS5cblxuICBUaGF0J3MgZXhhY3RseSB3aGF0J3MgaGFwcGVuaW5nIHdpdGggYE1heWJlLm1hcGAuIElmIHRoZSBjb250YWluZXIgaXMgKmVtcHR5KlxuICDigJPCoHRoZSBgTm90aGluZ2AgdmFyaWFudCDigJMgeW91IGp1c3QgZ2V0IGJhY2sgYW4gZW1wdHkgY29udGFpbmVyLiBJZiB0aGVcbiAgY29udGFpbmVyIGhhcyBzb21ldGhpbmcgaW4gaXQg4oCTwqB0aGUgYEp1c3RgIHZhcmlhbnQg4oCTwqB5b3UgZ2V0IGJhY2sgYSBjb250YWluZXJcbiAgd2l0aCB0aGUgaXRlbSBpbnNpZGUgdHJhbnNmb3JtZWQuXG5cbiAgKFNvLi4uIHdoeSBub3QganVzdCB1c2UgYW4gYXJyYXk/IFRoZSBiaWdnZXN0IHJlYXNvbiBpcyB0aGF0IGFuIGFycmF5IGNhbiBiZVxuICBhbnkgbGVuZ3RoLiBXaXRoIGEgYE1heWJlYCwgd2UncmUgY2FwdHVyaW5nIHRoZSBpZGVhIG9mIFwic29tZXRoaW5nIG9yXG4gIG5vdGhpbmdcIiByYXRoZXIgdGhhbiBcIjAgdG8gblwiIGl0ZW1zLiBBbmQgdGhpcyBsZXRzIHVzIGltcGxlbWVudCBhIHdob2xlIHNldFxuICBvZiAqb3RoZXIqIGludGVyZmFjZXMsIGxpa2UgdGhvc2UgaW4gdGhpcyBtb2R1bGUuKVxuXG4gICMjIyMgRXhhbXBsZXNcblxuICBgYGB0c1xuICBjb25zdCBsZW5ndGggPSAoczogc3RyaW5nKSA9PiBzLmxlbmd0aDtcblxuICBjb25zdCBqdXN0QVN0cmluZyA9IE1heWJlLmp1c3QoJ3N0cmluZycpO1xuICBjb25zdCBqdXN0VGhlU3RyaW5nTGVuZ3RoID0gbWFwKGxlbmd0aCwganVzdEFTdHJpbmcpO1xuICBjb25zb2xlLmxvZyhqdXN0VGhlU3RyaW5nTGVuZ3RoLnRvU3RyaW5nKCkpOyAvLyBKdXN0KDYpXG5cbiAgY29uc3Qgbm90QVN0cmluZyA9IE1heWJlLm5vdGhpbmc8c3RyaW5nPigpO1xuICBjb25zdCBub3RBU3RyaW5nTGVuZ3RoID0gbWFwKGxlbmd0aCwgbm90QVN0cmluZyk7XG4gIGNvbnNvbGUubG9nKG5vdEFTdHJpbmdMZW5ndGgudG9TdHJpbmcoKSk7IC8vIFwiTm90aGluZ1wiXG4gIGBgYFxuXG4gIEB0eXBlcGFyYW0gVCBUaGUgdHlwZSBvZiB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgQHR5cGVwYXJhbSBVIFRoZSB0eXBlIG9mIHRoZSB3cmFwcGVkIHZhbHVlIG9mIHRoZSByZXR1cm5lZCBgTWF5YmVgLlxuICBAcGFyYW0gbWFwRm4gVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IHRoZSB2YWx1ZSB0byBpZiBgTWF5YmVgIGlzIGBKdXN0YC5cbiAgQHBhcmFtIG1heWJlIFRoZSBgTWF5YmVgIGluc3RhbmNlIHRvIG1hcCBvdmVyLlxuICBAcmV0dXJucyAgICAgQSBuZXcgYE1heWJlYCB3aXRoIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgYG1hcEZuYCB0byB0aGUgdmFsdWVcbiAgICAgICAgICAgICAgIGluIGEgYEp1c3RgLCBvciBgTm90aGluZ2AgaWYgYG1heWJlYCBpcyBgTm90aGluZ2AuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXA8VCwgVT4obWFwRm46ICh0OiBUKSA9PiBVKTogKG1heWJlOiBNYXliZTxUPikgPT4gTWF5YmU8VT47XG5leHBvcnQgZnVuY3Rpb24gbWFwPFQsIFU+KG1hcEZuOiAodDogVCkgPT4gVSwgbWF5YmU6IE1heWJlPFQ+KTogTWF5YmU8VT47XG5leHBvcnQgZnVuY3Rpb24gbWFwPFQsIFU+KFxuICBtYXBGbjogKHQ6IFQpID0+IFUsXG4gIG1heWJlPzogTWF5YmU8VD5cbik6IE1heWJlPFU+IHwgKChtYXliZTogTWF5YmU8VD4pID0+IE1heWJlPFU+KSB7XG4gIGNvbnN0IG9wID0gKG06IE1heWJlPFQ+KSA9PiAobS5pc0p1c3QoKSA/IGp1c3QobWFwRm4obS52YWx1ZSkpIDogbm90aGluZzxVPigpKTtcbiAgcmV0dXJuIGN1cnJ5MShvcCwgbWF5YmUpO1xufVxuXG4vKipcbiAgTWFwIG92ZXIgYSBgTWF5YmVgIGluc3RhbmNlIGFuZCBnZXQgb3V0IHRoZSB2YWx1ZSBpZiBgbWF5YmVgIGlzIGEgYEp1c3RgLCBvclxuICByZXR1cm4gYSBkZWZhdWx0IHZhbHVlIGlmIGBtYXliZWAgaXMgYSBgTm90aGluZ2AuXG5cbiAgIyMjIyBFeGFtcGxlc1xuXG4gIGBgYHRzXG4gIGNvbnN0IGxlbmd0aCA9IChzOiBzdHJpbmcpID0+IHMubGVuZ3RoO1xuXG4gIGNvbnN0IGp1c3RBU3RyaW5nID0gTWF5YmUuanVzdCgnc3RyaW5nJyk7XG4gIGNvbnN0IHRoZVN0cmluZ0xlbmd0aCA9IG1hcE9yKDAsIGxlbmd0aCwganVzdEFTdHJpbmcpO1xuICBjb25zb2xlLmxvZyh0aGVTdHJpbmdMZW5ndGgpOyAvLyA2XG5cbiAgY29uc3Qgbm90QVN0cmluZyA9IE1heWJlLm5vdGhpbmc8c3RyaW5nPigpO1xuICBjb25zdCBub3RBU3RyaW5nTGVuZ3RoID0gbWFwT3IoMCwgbGVuZ3RoLCBub3RBU3RyaW5nKVxuICBjb25zb2xlLmxvZyhub3RBU3RyaW5nTGVuZ3RoKTsgLy8gMFxuICBgYGBcblxuICBAdHlwZXBhcmFtIFQgVGhlIHR5cGUgb2YgdGhlIHdyYXBwZWQgdmFsdWUuXG4gIEB0eXBlcGFyYW0gVSBUaGUgdHlwZSBvZiB0aGUgd3JhcHBlZCB2YWx1ZSBvZiB0aGUgcmV0dXJuZWQgYE1heWJlYC5cbiAgQHBhcmFtIG9yVSAgIFRoZSBkZWZhdWx0IHZhbHVlIHRvIHVzZSBpZiBgbWF5YmVgIGlzIGBOb3RoaW5nYFxuICBAcGFyYW0gbWFwRm4gVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IHRoZSB2YWx1ZSB0byBpZiBgTWF5YmVgIGlzIGBKdXN0YFxuICBAcGFyYW0gbWF5YmUgVGhlIGBNYXliZWAgaW5zdGFuY2UgdG8gbWFwIG92ZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBPcjxULCBVPihvclU6IFUsIG1hcEZuOiAodDogVCkgPT4gVSwgbWF5YmU6IE1heWJlPFQ+KTogVTtcbmV4cG9ydCBmdW5jdGlvbiBtYXBPcjxULCBVPihvclU6IFUsIG1hcEZuOiAodDogVCkgPT4gVSk6IChtYXliZTogTWF5YmU8VD4pID0+IFU7XG5leHBvcnQgZnVuY3Rpb24gbWFwT3I8VCwgVT4ob3JVOiBVKTogKG1hcEZuOiAodDogVCkgPT4gVSkgPT4gKG1heWJlOiBNYXliZTxUPikgPT4gVTtcbmV4cG9ydCBmdW5jdGlvbiBtYXBPcjxULCBVPihcbiAgb3JVOiBVLFxuICBtYXBGbj86ICh0OiBUKSA9PiBVLFxuICBtYXliZT86IE1heWJlPFQ+XG4pOiBVIHwgKChtYXliZTogTWF5YmU8VD4pID0+IFUpIHwgKChtYXBGbjogKHQ6IFQpID0+IFUpID0+IChtYXliZTogTWF5YmU8VD4pID0+IFUpIHtcbiAgZnVuY3Rpb24gZnVsbE9wKGZuOiAodDogVCkgPT4gVSwgbTogTWF5YmU8VD4pIHtcbiAgICByZXR1cm4gbS5pc0p1c3QoKSA/IGZuKG0udmFsdWUpIDogb3JVO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFydGlhbE9wKGZuOiAodDogVCkgPT4gVSk6IChtYXliZTogTWF5YmU8VD4pID0+IFU7XG4gIGZ1bmN0aW9uIHBhcnRpYWxPcChmbjogKHQ6IFQpID0+IFUsIGN1cnJpZWRNYXliZTogTWF5YmU8VD4pOiBVO1xuICBmdW5jdGlvbiBwYXJ0aWFsT3AoZm46ICh0OiBUKSA9PiBVLCBjdXJyaWVkTWF5YmU/OiBNYXliZTxUPik6IFUgfCAoKG1heWJlOiBNYXliZTxUPikgPT4gVSkge1xuICAgIHJldHVybiBjdXJyaWVkTWF5YmUgIT09IHVuZGVmaW5lZFxuICAgICAgPyBmdWxsT3AoZm4sIGN1cnJpZWRNYXliZSlcbiAgICAgIDogKGV4dHJhQ3VycmllZE1heWJlOiBNYXliZTxUPikgPT4gZnVsbE9wKGZuLCBleHRyYUN1cnJpZWRNYXliZSk7XG4gIH1cblxuICByZXR1cm4gbWFwRm4gPT09IHVuZGVmaW5lZFxuICAgID8gcGFydGlhbE9wXG4gICAgOiBtYXliZSA9PT0gdW5kZWZpbmVkXG4gICAgICA/IHBhcnRpYWxPcChtYXBGbilcbiAgICAgIDogcGFydGlhbE9wKG1hcEZuLCBtYXliZSk7XG59XG5cbi8qKlxuICBNYXAgb3ZlciBhIGBNYXliZWAgaW5zdGFuY2UgYW5kIGdldCBvdXQgdGhlIHZhbHVlIGlmIGBtYXliZWAgaXMgYSBgSnVzdGAsXG4gIG9yIHVzZSBhIGZ1bmN0aW9uIHRvIGNvbnN0cnVjdCBhIGRlZmF1bHQgdmFsdWUgaWYgYG1heWJlYCBpcyBgTm90aGluZ2AuXG5cbiAgIyMjIyBFeGFtcGxlc1xuXG4gIGBgYHRzXG4gIGNvbnN0IGxlbmd0aCA9IChzOiBzdHJpbmcpID0+IHMubGVuZ3RoO1xuICBjb25zdCBnZXREZWZhdWx0ID0gKCkgPT4gMDtcblxuICBjb25zdCBqdXN0QVN0cmluZyA9IE1heWJlLmp1c3QoJ3N0cmluZycpO1xuICBjb25zdCB0aGVTdHJpbmdMZW5ndGggPSBtYXBPckVsc2UoZ2V0RGVmYXVsdCwgbGVuZ3RoLCBqdXN0QVN0cmluZyk7XG4gIGNvbnNvbGUubG9nKHRoZVN0cmluZ0xlbmd0aCk7IC8vIDZcblxuICBjb25zdCBub3RBU3RyaW5nID0gTWF5YmUubm90aGluZzxzdHJpbmc+KCk7XG4gIGNvbnN0IG5vdEFTdHJpbmdMZW5ndGggPSBtYXBPckVsc2UoZ2V0RGVmYXVsdCwgbGVuZ3RoLCBub3RBU3RyaW5nKVxuICBjb25zb2xlLmxvZyhub3RBU3RyaW5nTGVuZ3RoKTsgLy8gMFxuICBgYGBcblxuICBAdHlwZXBhcmFtIFQgICAgVGhlIHR5cGUgb2YgdGhlIHdyYXBwZWQgdmFsdWUuXG4gIEB0eXBlcGFyYW0gVSAgICBUaGUgdHlwZSBvZiB0aGUgd3JhcHBlZCB2YWx1ZSBvZiB0aGUgcmV0dXJuZWQgYE1heWJlYC5cbiAgQHBhcmFtIG9yRWxzZUZuIFRoZSBmdW5jdGlvbiB0byBhcHBseSBpZiBgbWF5YmVgIGlzIGBOb3RoaW5nYC5cbiAgQHBhcmFtIG1hcEZuICAgIFRoZSBmdW5jdGlvbiB0byBhcHBseSB0byB0aGUgd3JhcHBlZCB2YWx1ZSBpZiBgbWF5YmVgIGlzIGBKdXN0YFxuICBAcGFyYW0gbWF5YmUgICAgVGhlIGBNYXliZWAgaW5zdGFuY2UgdG8gbWFwIG92ZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBPckVsc2U8VCwgVT4ob3JFbHNlRm46ICgpID0+IFUsIG1hcEZuOiAodDogVCkgPT4gVSwgbWF5YmU6IE1heWJlPFQ+KTogVTtcbmV4cG9ydCBmdW5jdGlvbiBtYXBPckVsc2U8VCwgVT4ob3JFbHNlRm46ICgpID0+IFUsIG1hcEZuOiAodDogVCkgPT4gVSk6IChtYXliZTogTWF5YmU8VD4pID0+IFU7XG5leHBvcnQgZnVuY3Rpb24gbWFwT3JFbHNlPFQsIFU+KG9yRWxzZUZuOiAoKSA9PiBVKTogKG1hcEZuOiAodDogVCkgPT4gVSkgPT4gKG1heWJlOiBNYXliZTxUPikgPT4gVTtcbmV4cG9ydCBmdW5jdGlvbiBtYXBPckVsc2U8VCwgVT4oXG4gIG9yRWxzZUZuOiAoKSA9PiBVLFxuICBtYXBGbj86ICh0OiBUKSA9PiBVLFxuICBtYXliZT86IE1heWJlPFQ+XG4pOiBVIHwgKChtYXliZTogTWF5YmU8VD4pID0+IFUpIHwgKChtYXBGbjogKHQ6IFQpID0+IFUpID0+IChtYXliZTogTWF5YmU8VD4pID0+IFUpIHtcbiAgZnVuY3Rpb24gZnVsbE9wKGZuOiAodDogVCkgPT4gVSwgbTogTWF5YmU8VD4pIHtcbiAgICByZXR1cm4gbS5pc0p1c3QoKSA/IGZuKG0udmFsdWUpIDogb3JFbHNlRm4oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnRpYWxPcChmbjogKHQ6IFQpID0+IFUpOiAobWF5YmU6IE1heWJlPFQ+KSA9PiBVO1xuICBmdW5jdGlvbiBwYXJ0aWFsT3AoZm46ICh0OiBUKSA9PiBVLCBjdXJyaWVkTWF5YmU6IE1heWJlPFQ+KTogVTtcbiAgZnVuY3Rpb24gcGFydGlhbE9wKGZuOiAodDogVCkgPT4gVSwgY3VycmllZE1heWJlPzogTWF5YmU8VD4pOiBVIHwgKChtYXliZTogTWF5YmU8VD4pID0+IFUpIHtcbiAgICByZXR1cm4gY3VycmllZE1heWJlICE9PSB1bmRlZmluZWRcbiAgICAgID8gZnVsbE9wKGZuLCBjdXJyaWVkTWF5YmUpXG4gICAgICA6IChleHRyYUN1cnJpZWRNYXliZTogTWF5YmU8VD4pID0+IGZ1bGxPcChmbiwgZXh0cmFDdXJyaWVkTWF5YmUpO1xuICB9XG5cbiAgaWYgKG1hcEZuID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcGFydGlhbE9wO1xuICB9IGVsc2UgaWYgKG1heWJlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcGFydGlhbE9wKG1hcEZuKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGFydGlhbE9wKG1hcEZuLCBtYXliZSk7XG4gIH1cbn1cblxuLyoqXG4gIFlvdSBjYW4gdGhpbmsgb2YgdGhpcyBsaWtlIGEgc2hvcnQtY2lyY3VpdGluZyBsb2dpY2FsIFwiYW5kXCIgb3BlcmF0aW9uIG9uIGFcbiAgYE1heWJlYCB0eXBlLiBJZiBgbWF5YmVgIGlzIGBKdXN0YCwgdGhlbiB0aGUgcmVzdWx0IGlzIHRoZSBgYW5kTWF5YmVgLiBJZlxuICBgbWF5YmVgIGlzIGBOb3RoaW5nYCwgdGhlIHJlc3VsdCBpcyBgTm90aGluZ2AuXG5cbiAgVGhpcyBpcyB1c2VmdWwgd2hlbiB5b3UgaGF2ZSBhbm90aGVyIGBNYXliZWAgdmFsdWUgeW91IHdhbnQgdG8gcHJvdmlkZSBpZiBhbmRcbiAgKm9ubHkgaWYqIHlvdSBoYXZlIGEgYEp1c3RgIOKAkyB0aGF0IGlzLCB3aGVuIHlvdSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGlmIHlvdVxuICBgTm90aGluZ2AsIHdoYXRldmVyIGVsc2UgeW91J3JlIGhhbmRpbmcgYSBgTWF5YmVgIHRvICphbHNvKiBnZXRzIGEgYE5vdGhpbmdgLlxuXG4gIE5vdGljZSB0aGF0LCB1bmxpa2UgaW4gW2BtYXBgXSgjbWFwKSBvciBpdHMgdmFyaWFudHMsIHRoZSBvcmlnaW5hbCBgbWF5YmVgIGlzXG4gIG5vdCBpbnZvbHZlZCBpbiBjb25zdHJ1Y3RpbmcgdGhlIG5ldyBgTWF5YmVgLlxuXG4gICMjIyMgRXhhbXBsZXNcblxuICBgYGB0c1xuICBpbXBvcnQgTWF5YmUgZnJvbSAndHJ1ZS1teXRoL21heWJlJztcblxuICBjb25zdCBqdXN0QSA9IE1heWJlLmp1c3QoJ0EnKTtcbiAgY29uc3QganVzdEIgPSBNYXliZS5qdXN0KCdCJyk7XG4gIGNvbnN0IG5vdGhpbmc6IE1heWJlPG51bWJlcj4gPSBub3RoaW5nKCk7XG5cbiAgY29uc29sZS5sb2coTWF5YmUuYW5kKGp1c3RCLCBqdXN0QSkudG9TdHJpbmcoKSk7ICAvLyBKdXN0KEIpXG4gIGNvbnNvbGUubG9nKE1heWJlLmFuZChqdXN0Qiwgbm90aGluZykudG9TdHJpbmcoKSk7ICAvLyBOb3RoaW5nXG4gIGNvbnNvbGUubG9nKE1heWJlLmFuZChub3RoaW5nLCBqdXN0QSkudG9TdHJpbmcoKSk7ICAvLyBOb3RoaW5nXG4gIGNvbnNvbGUubG9nKE1heWJlLmFuZChub3RoaW5nLCBub3RoaW5nKS50b1N0cmluZygpKTsgIC8vIE5vdGhpbmdcbiAgYGBgXG5cbiAgQHR5cGVwYXJhbSBUICAgIFRoZSB0eXBlIG9mIHRoZSBpbml0aWFsIHdyYXBwZWQgdmFsdWUuXG4gIEB0eXBlcGFyYW0gVSAgICBUaGUgdHlwZSBvZiB0aGUgd3JhcHBlZCB2YWx1ZSBvZiB0aGUgcmV0dXJuZWQgYE1heWJlYC5cbiAgQHBhcmFtIGFuZE1heWJlIFRoZSBgTWF5YmVgIGluc3RhbmNlIHRvIHJldHVybiBpZiBgbWF5YmVgIGlzIGBKdXN0YFxuICBAcGFyYW0gbWF5YmUgICAgVGhlIGBNYXliZWAgaW5zdGFuY2UgdG8gY2hlY2suXG4gIEByZXR1cm4gICAgICAgICBgTm90aGluZ2AgaWYgdGhlIG9yaWdpbmFsIGBtYXliZWAgaXMgYE5vdGhpbmdgLCBvciBgYW5kTWF5YmVgXG4gICAgICAgICAgICAgICAgICBpZiB0aGUgb3JpZ2luYWwgYG1heWJlYCBpcyBgSnVzdGAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbmQ8VCwgVT4oYW5kTWF5YmU6IE1heWJlPFU+LCBtYXliZTogTWF5YmU8VD4pOiBNYXliZTxVPjtcbmV4cG9ydCBmdW5jdGlvbiBhbmQ8VCwgVT4oYW5kTWF5YmU6IE1heWJlPFU+KTogKG1heWJlOiBNYXliZTxUPikgPT4gTWF5YmU8VT47XG5leHBvcnQgZnVuY3Rpb24gYW5kPFQsIFU+KFxuICBhbmRNYXliZTogTWF5YmU8VT4sXG4gIG1heWJlPzogTWF5YmU8VD5cbik6IE1heWJlPFU+IHwgKChtYXliZTogTWF5YmU8VD4pID0+IE1heWJlPFU+KSB7XG4gIGNvbnN0IG9wID0gKG06IE1heWJlPFQ+KSA9PiAobS5pc0p1c3QoKSA/IGFuZE1heWJlIDogbm90aGluZzxVPigpKTtcbiAgcmV0dXJuIGN1cnJ5MShvcCwgbWF5YmUpO1xufVxuXG4vKipcbiAgQXBwbHkgYSBmdW5jdGlvbiB0byB0aGUgd3JhcHBlZCB2YWx1ZSBpZiBgSnVzdGAgYW5kIHJldHVybiBhIG5ldyBgSnVzdGBcbiAgY29udGFpbmluZyB0aGUgcmVzdWx0aW5nIHZhbHVlOyBvciByZXR1cm4gYE5vdGhpbmdgIGlmIGBOb3RoaW5nYC5cblxuICBUaGlzIGRpZmZlcnMgZnJvbSBgbWFwYCBpbiB0aGF0IGB0aGVuRm5gIHJldHVybnMgYW5vdGhlciBgTWF5YmVgLiBZb3UgY2FuIHVzZVxuICBgYW5kVGhlbmAgdG8gY29tYmluZSB0d28gZnVuY3Rpb25zIHdoaWNoICpib3RoKiBjcmVhdGUgYSBgTWF5YmVgIGZyb20gYW5cbiAgdW53cmFwcGVkIHR5cGUuXG5cbiAgWW91IG1heSBmaW5kIHRoZSBgLnRoZW5gIG1ldGhvZCBvbiBhbiBFUzYgYFByb21pc2VgIGhlbHBmdWwgZm9yIGI6XG4gIGlmIHlvdSBoYXZlIGEgYFByb21pc2VgLCB5b3UgY2FuIHBhc3MgaXRzIGB0aGVuYCBtZXRob2QgYSBjYWxsYmFjayB3aGljaFxuICByZXR1cm5zIGFub3RoZXIgYFByb21pc2VgLCBhbmQgdGhlIHJlc3VsdCB3aWxsIG5vdCBiZSBhICpuZXN0ZWQqIHByb21pc2UsIGJ1dFxuICBhIHNpbmdsZSBgUHJvbWlzZWAuIFRoZSBkaWZmZXJlbmNlIGlzIHRoYXQgYFByb21pc2UjdGhlbmAgdW53cmFwcyAqYWxsKlxuICBsYXllcnMgdG8gb25seSBldmVyIHJldHVybiBhIHNpbmdsZSBgUHJvbWlzZWAgdmFsdWUsIHdoZXJlYXMgYE1heWJlLmFuZFRoZW5gXG4gIHdpbGwgbm90IHVud3JhcCBuZXN0ZWQgYE1heWJlYHMuXG5cbiAgVGhpcyBpcyBhbHNvIGNvbW1vbmx5IGtub3duIGFzIChhbmQgdGhlcmVmb3JlIGFsaWFzZWQgYXMpIFtgZmxhdE1hcGBdIG9yXG4gIFtgY2hhaW5gXS4gSXQgaXMgc29tZXRpbWVzIGFsc28ga25vd24gYXMgYGJpbmRgLCBidXQgKm5vdCogYWxpYXNlZCBhcyBzdWNoXG4gIGJlY2F1c2UgW2BiaW5kYCBhbHJlYWR5IG1lYW5zIHNvbWV0aGluZyBpbiBKYXZhU2NyaXB0XVtiaW5kXS5cblxuICBbYGZsYXRNYXBgXTogI2ZsYXRtYXBcbiAgW2BjaGFpbmBdOiAjY2hhaW5cbiAgW2JpbmRdOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9iaW5kXG5cbiAgIyMjIyBFeGFtcGxlXG5cbiAgKFRoaXMgaXMgYSBzb21ld2hhdCBjb250cml2ZWQgZXhhbXBsZSwgYnV0IGl0IHNlcnZlcyB0byBzaG93IHRoZSB3YXkgdGhlXG4gIGZ1bmN0aW9uIGJlaGF2ZXMuKVxuXG4gIGBgYHRzXG4gIGltcG9ydCBNYXliZSBmcm9tICd0cnVlLW15dGgvbWF5YmUnO1xuXG4gIC8vIHN0cmluZyAtPiBNYXliZTxudW1iZXI+XG4gIGNvbnN0IHRvTWF5YmVMZW5ndGggPSAoczogc3RyaW5nKTogTWF5YmU8bnVtYmVyPiA9PiBNYXliZS5vZihzLmxlbmd0aCk7XG5cbiAgLy8gTWF5YmU8c3RyaW5nPlxuICBjb25zdCBhTWF5YmVTdHJpbmcgPSBNYXliZS5vZignSGVsbG8sIHRoZXJlIScpO1xuXG4gIC8vIE1heWJlPG51bWJlcj5cbiAgY29uc3QgcmVzdWx0aW5nTGVuZ3RoID0gTWF5YmUuYW5kVGhlbih0b01heWJlTGVuZ3RoLCBhTWF5YmVTdHJpbmcpO1xuICBjb25zb2xlLmxvZyhNYXliZS50b1N0cmluZyhyZXN1bHRpbmdMZW5ndGgpKTsgLy8gMTNcbiAgYGBgXG5cbiAgTm90ZSB0aGF0IHRoZSByZXN1bHQgaXMgbm90IGAoSnVzdCgxMykpYCwgYnV0IGAxM2AhXG5cbiAgQHR5cGVwYXJhbSBUICBUaGUgdHlwZSBvZiB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgQHR5cGVwYXJhbSBUICBUaGUgdHlwZSBvZiB0aGUgd3JhcHBlZCB2YWx1ZSBpbiB0aGUgcmVzdWx0aW5nIGBNYXliZWAuXG4gIEBwYXJhbSB0aGVuRm4gVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIHRoZSB3cmFwcGVkIGBUYCBpZiBgbWF5YmVgIGlzIGBKdXN0YC5cbiAgQHBhcmFtIG1heWJlICBUaGUgYE1heWJlYCB0byBldmFsdWF0ZSBhbmQgcG9zc2libHkgYXBwbHkgYSBmdW5jdGlvbiB0byB0aGVcbiAgICAgICAgICAgICAgICBjb250ZW50cyBvZi5cbiAgQHJldHVybnMgICAgICBUaGUgcmVzdWx0IG9mIHRoZSBgdGhlbkZuYCAoYSBuZXcgYE1heWJlYCkgaWYgYG1heWJlYCBpcyBhXG4gICAgICAgICAgICAgICAgYEp1c3RgLCBvdGhlcndpc2UgYE5vdGhpbmdgIGlmIGBtYXliZWAgaXMgYSBgTm90aGluZ2AuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbmRUaGVuPFQsIFU+KHRoZW5GbjogKHQ6IFQpID0+IE1heWJlPFU+LCBtYXliZTogTWF5YmU8VD4pOiBNYXliZTxVPjtcbmV4cG9ydCBmdW5jdGlvbiBhbmRUaGVuPFQsIFU+KHRoZW5GbjogKHQ6IFQpID0+IE1heWJlPFU+KTogKG1heWJlOiBNYXliZTxUPikgPT4gTWF5YmU8VT47XG5leHBvcnQgZnVuY3Rpb24gYW5kVGhlbjxULCBVPihcbiAgdGhlbkZuOiAodDogVCkgPT4gTWF5YmU8VT4sXG4gIG1heWJlPzogTWF5YmU8VD5cbik6IE1heWJlPFU+IHwgKChtYXliZTogTWF5YmU8VD4pID0+IE1heWJlPFU+KSB7XG4gIGNvbnN0IG9wID0gKG06IE1heWJlPFQ+KSA9PiAobS5pc0p1c3QoKSA/IHRoZW5GbihtLnZhbHVlKSA6IG5vdGhpbmc8VT4oKSk7XG4gIHJldHVybiBtYXliZSAhPT0gdW5kZWZpbmVkID8gb3AobWF5YmUpIDogb3A7XG59XG5cbi8qKiBBbGlhcyBmb3IgW2BhbmRUaGVuYF0oI2FuZHRoZW4pLiAqL1xuZXhwb3J0IGNvbnN0IGNoYWluID0gYW5kVGhlbjtcblxuLyoqIEFsaWFzIGZvciBbYGFuZFRoZW5gXSgjYW5kdGhlbikuICovXG5leHBvcnQgY29uc3QgZmxhdE1hcCA9IGFuZFRoZW47XG5cbi8qKlxuICBQcm92aWRlIGEgZmFsbGJhY2sgZm9yIGEgZ2l2ZW4gYE1heWJlYC4gQmVoYXZlcyBsaWtlIGEgbG9naWNhbCBgb3JgOiBpZiB0aGVcbiAgYG1heWJlYCB2YWx1ZSBpcyBhIGBKdXN0YCwgcmV0dXJucyB0aGF0IGBtYXliZWA7IG90aGVyd2lzZSwgcmV0dXJucyB0aGVcbiAgYGRlZmF1bHRNYXliZWAgdmFsdWUuXG5cbiAgVGhpcyBpcyB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0byBtYWtlIHN1cmUgdGhhdCBzb21ldGhpbmcgd2hpY2ggdGFrZXMgYVxuICBgTWF5YmVgIGFsd2F5cyBlbmRzIHVwIGdldHRpbmcgYSBgSnVzdGAgdmFyaWFudCwgYnkgc3VwcGx5aW5nIGEgZGVmYXVsdCB2YWx1ZVxuICBmb3IgdGhlIGNhc2UgdGhhdCB5b3UgY3VycmVudGx5IGhhdmUgYSBub3RoaW5nLlxuXG4gIGBgYHRzXG4gIGltcG9ydCBNYXliZSBmcm9tICd0cnVlLXV0aWxzL21heWJlJztcblxuICBjb25zdCBqdXN0QSA9IE1heWJlLmp1c3QoXCJhXCIpO1xuICBjb25zdCBqdXN0QiA9IE1heWJlLmp1c3QoXCJiXCIpO1xuICBjb25zdCBhTm90aGluZzogTWF5YmU8c3RyaW5nPiA9IG5vdGhpbmcoKTtcblxuICBjb25zb2xlLmxvZyhNYXliZS5vcihqdXN0QiwganVzdEEpLnRvU3RyaW5nKCkpOyAgLy8gSnVzdChBKVxuICBjb25zb2xlLmxvZyhNYXliZS5vcihhTm90aGluZywganVzdEEpLnRvU3RyaW5nKCkpOyAgLy8gSnVzdChBKVxuICBjb25zb2xlLmxvZyhNYXliZS5vcihqdXN0QiwgYU5vdGhpbmcpLnRvU3RyaW5nKCkpOyAgLy8gSnVzdChCKVxuICBjb25zb2xlLmxvZyhNYXliZS5vcihhTm90aGluZywgYU5vdGhpbmcpLnRvU3RyaW5nKCkpOyAgLy8gTm90aGluZ1xuICBgYGBcblxuICBAdHlwZXBhcmFtIFQgICAgICAgIFRoZSB0eXBlIG9mIHRoZSB3cmFwcGVkIHZhbHVlLlxuICBAcGFyYW0gZGVmYXVsdE1heWJlIFRoZSBgTWF5YmVgIHRvIHVzZSBpZiBgbWF5YmVgIGlzIGEgYE5vdGhpbmdgLlxuICBAcGFyYW0gbWF5YmUgICAgICAgIFRoZSBgTWF5YmVgIGluc3RhbmNlIHRvIGV2YWx1YXRlLlxuICBAcmV0dXJucyAgICAgICAgICAgIGBtYXliZWAgaWYgaXQgaXMgYSBgSnVzdGAsIG90aGVyd2lzZSBgZGVmYXVsdE1heWJlYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9yPFQ+KGRlZmF1bHRNYXliZTogTWF5YmU8VD4sIG1heWJlOiBNYXliZTxUPik6IE1heWJlPFQ+O1xuZXhwb3J0IGZ1bmN0aW9uIG9yPFQ+KGRlZmF1bHRNYXliZTogTWF5YmU8VD4pOiAobWF5YmU6IE1heWJlPFQ+KSA9PiBNYXliZTxUPjtcbmV4cG9ydCBmdW5jdGlvbiBvcjxUPihcbiAgZGVmYXVsdE1heWJlOiBNYXliZTxUPixcbiAgbWF5YmU/OiBNYXliZTxUPlxuKTogTWF5YmU8VD4gfCAoKG1heWJlOiBNYXliZTxUPikgPT4gTWF5YmU8VD4pIHtcbiAgY29uc3Qgb3AgPSAobTogTWF5YmU8VD4pID0+IChtLmlzSnVzdCgpID8gbSA6IGRlZmF1bHRNYXliZSk7XG4gIHJldHVybiBtYXliZSAhPT0gdW5kZWZpbmVkID8gb3AobWF5YmUpIDogb3A7XG59XG5cbi8qKlxuICBMaWtlIGBvcmAsIGJ1dCB1c2luZyBhIGZ1bmN0aW9uIHRvIGNvbnN0cnVjdCB0aGUgYWx0ZXJuYXRpdmUgYE1heWJlYC5cblxuICBTb21ldGltZXMgeW91IG5lZWQgdG8gcGVyZm9ybSBhbiBvcGVyYXRpb24gdXNpbmcgb3RoZXIgZGF0YSBpbiB0aGVcbiAgZW52aXJvbm1lbnQgdG8gY29uc3RydWN0IHRoZSBmYWxsYmFjayB2YWx1ZS4gSW4gdGhlc2Ugc2l0dWF0aW9ucywgeW91IGNhblxuICBwYXNzIGEgZnVuY3Rpb24gKHdoaWNoIG1heSBiZSBhIGNsb3N1cmUpIGFzIHRoZSBgZWxzZUZuYCB0byBnZW5lcmF0ZSB0aGVcbiAgZmFsbGJhY2sgYE1heWJlPFQ+YC5cblxuICBVc2VmdWwgZm9yIHRyYW5zZm9ybWluZyBlbXB0eSBzY2VuYXJpb3MgYmFzZWQgb24gdmFsdWVzIGluIGNvbnRleHQuXG5cbiAgQHR5cGVwYXJhbSBUICBUaGUgdHlwZSBvZiB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgQHBhcmFtIGVsc2VGbiBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgaWYgYG1heWJlYCBpcyBgTm90aGluZ2BcbiAgQHBhcmFtIG1heWJlICBUaGUgYG1heWJlYCB0byB1c2UgaWYgaXQgaXMgYEp1c3RgLlxuICBAcmV0dXJucyAgICAgIFRoZSBgbWF5YmVgIGlmIGl0IGlzIGBKdXN0YCwgb3IgdGhlIGBNYXliZWAgcmV0dXJuZWQgYnlcbiAgICAgICAgICAgICAgICBgZWxzZUZuYCBpZiB0aGUgYG1heWJlYCBpcyBgTm90aGluZ2AuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvckVsc2U8VD4oZWxzZUZuOiAoKSA9PiBNYXliZTxUPiwgbWF5YmU6IE1heWJlPFQ+KTogTWF5YmU8VD47XG5leHBvcnQgZnVuY3Rpb24gb3JFbHNlPFQ+KGVsc2VGbjogKCkgPT4gTWF5YmU8VD4pOiAobWF5YmU6IE1heWJlPFQ+KSA9PiBNYXliZTxUPjtcbmV4cG9ydCBmdW5jdGlvbiBvckVsc2U8VD4oXG4gIGVsc2VGbjogKCkgPT4gTWF5YmU8VD4sXG4gIG1heWJlPzogTWF5YmU8VD5cbik6IE1heWJlPFQ+IHwgKChtYXliZTogTWF5YmU8VD4pID0+IE1heWJlPFQ+KSB7XG4gIGNvbnN0IG9wID0gKG06IE1heWJlPFQ+KSA9PiAobS5pc0p1c3QoKSA/IG0gOiBlbHNlRm4oKSk7XG4gIHJldHVybiBjdXJyeTEob3AsIG1heWJlKTtcbn1cblxuLyoqXG4gIEdldCB0aGUgdmFsdWUgb3V0IG9mIHRoZSBgTWF5YmVgLlxuXG4gIFJldHVybnMgdGhlIGNvbnRlbnQgb2YgYSBgSnVzdGAsIGJ1dCAqKnRocm93cyBpZiB0aGUgYE1heWJlYCBpcyBgTm90aGluZ2AqKi5cbiAgUHJlZmVyIHRvIHVzZSBbYHVud3JhcE9yYF0oI3Vud3JhcG9yKSBvciBbYHVud3JhcE9yRWxzZWBdKCN1bndyYXBvcmVsc2UpLlxuXG4gIEB0eXBlcGFyYW0gVCBUaGUgdHlwZSBvZiB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgQHBhcmFtIG1heWJlIFRoZSB2YWx1ZSB0byB1bndyYXBcbiAgQHJldHVybnMgICAgIFRoZSB1bndyYXBwZWQgdmFsdWUgaWYgdGhlIGBNYXliZWAgaW5zdGFuY2UgaXMgYEp1c3RgLlxuICBAdGhyb3dzICAgICAgSWYgdGhlIGBtYXliZWAgaXMgYE5vdGhpbmdgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5zYWZlbHlVbndyYXA8VD4obWF5YmU6IE1heWJlPFQ+KTogVCB7XG4gIHJldHVybiBtYXliZS51bnNhZmVseVVud3JhcCgpO1xufVxuXG4vKiogQWxpYXMgZm9yIFtgdW5zYWZlbHlVbndyYXBgXSgjdW5zYWZlbHl1bndyYXApICovXG5leHBvcnQgY29uc3QgdW5zYWZlbHlHZXQgPSB1bnNhZmVseVVud3JhcDtcblxuLyoqIEFsaWFzIGZvciBbYHVuc2FmZWx5VW53cmFwYF0oI3Vuc2FmZWx5dW53cmFwKSAqL1xuZXhwb3J0IGNvbnN0IHVuc2FmZUdldCA9IHVuc2FmZWx5VW53cmFwO1xuXG4vKipcbiAgU2FmZWx5IGdldCB0aGUgdmFsdWUgb3V0IG9mIGEgYE1heWJlYC5cblxuICBSZXR1cm5zIHRoZSBjb250ZW50IG9mIGEgYEp1c3RgIG9yIGBkZWZhdWx0VmFsdWVgIGlmIGBOb3RoaW5nYC4gVGhpcyBpcyB0aGVcbiAgcmVjb21tZW5kZWQgd2F5IHRvIGdldCBhIHZhbHVlIG91dCBvZiBhIGBNYXliZWAgbW9zdCBvZiB0aGUgdGltZS5cblxuICBgYGB0c1xuICBpbXBvcnQgTWF5YmUgZnJvbSAndHJ1ZS1teXRoL21heWJlJztcblxuICBjb25zdCBub3RBU3RyaW5nID0gTWF5YmUubm90aGluZzxzdHJpbmc+KCk7XG4gIGNvbnN0IGlzQVN0cmluZyA9IE1heWJlLmp1c3QoJ2xvb2sgbWEhIHNvbWUgY2hhcmFjdGVycyEnKTtcblxuICBjb25zb2xlLmxvZyhNYXliZS51bndyYXBPcignPGVtcHR5PicsIG5vdEFTdHJpbmcpKTsgIC8vIFwiPGVtcHR5PlwiXG4gIGNvbnNvbGUubG9nKE1heWJlLnVud3JhcE9yKCc8ZW1wdHk+JywgaXNBU3RyaW5nKSk7ICAvLyBcImxvb2sgbWEhIHNvbWUgY2hhcmFjdGVycyFcIlxuICBgYGBcblxuICBAdHlwZXBhcmFtIFQgICAgICAgIFRoZSB0eXBlIG9mIHRoZSB3cmFwcGVkIHZhbHVlLlxuICBAcGFyYW0gZGVmYXVsdFZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgYG1heWJlYCBpcyBhIGBOb3RoaW5nYC5cbiAgQHBhcmFtIG1heWJlICAgICAgICBUaGUgYE1heWJlYCBpbnN0YW5jZSB0byB1bndyYXAgaWYgaXQgaXMgYSBgSnVzdGAuXG4gIEByZXR1cm5zICAgICAgICAgICAgVGhlIGNvbnRlbnQgb2YgYG1heWJlYCBpZiBpdCBpcyBhIGBKdXN0YCwgb3RoZXJ3aXNlXG4gICAgICAgICAgICAgICAgICAgICAgYGRlZmF1bHRWYWx1ZWAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bndyYXBPcjxUPihkZWZhdWx0VmFsdWU6IFQsIG1heWJlOiBNYXliZTxUPik6IFQ7XG5leHBvcnQgZnVuY3Rpb24gdW53cmFwT3I8VD4oZGVmYXVsdFZhbHVlOiBUKTogKG1heWJlOiBNYXliZTxUPikgPT4gVDtcbmV4cG9ydCBmdW5jdGlvbiB1bndyYXBPcjxUPihkZWZhdWx0VmFsdWU6IFQsIG1heWJlPzogTWF5YmU8VD4pIHtcbiAgY29uc3Qgb3AgPSAobTogTWF5YmU8VD4pID0+IChtLmlzSnVzdCgpID8gbS52YWx1ZSA6IGRlZmF1bHRWYWx1ZSk7XG4gIHJldHVybiBjdXJyeTEob3AsIG1heWJlKTtcbn1cblxuLyoqIEFsaWFzIGZvciBbYHVud3JhcE9yYF0oI3Vud3JhcG9yKSAqL1xuZXhwb3J0IGNvbnN0IGdldE9yID0gdW53cmFwT3I7XG5cbi8qKlxuICBTYWZlbHkgZ2V0IHRoZSB2YWx1ZSBvdXQgb2YgYSBbYE1heWJlYF0oI21heWJlKSBieSByZXR1cm5pbmcgdGhlIHdyYXBwZWRcbiAgdmFsdWUgaWYgaXQgaXMgYEp1c3RgLCBvciBieSBhcHBseWluZyBgb3JFbHNlRm5gIGlmIGl0IGlzIGBOb3RoaW5nYC5cblxuICBUaGlzIGlzIHVzZWZ1bCB3aGVuIHlvdSBuZWVkIHRvICpnZW5lcmF0ZSogYSB2YWx1ZSAoZS5nLiBieSB1c2luZyBjdXJyZW50XG4gIHZhbHVlcyBpbiB0aGUgZW52aXJvbm1lbnQg4oCTIHdoZXRoZXIgcHJlbG9hZGVkIG9yIGJ5IGxvY2FsIGNsb3N1cmUpIGluc3RlYWQgb2ZcbiAgaGF2aW5nIGEgc2luZ2xlIGRlZmF1bHQgdmFsdWUgYXZhaWxhYmxlIChhcyBpbiBbYHVud3JhcE9yYF0oI3Vud3JhcG9yKSkuXG5cbiAgYGBgdHNcbiAgaW1wb3J0IE1heWJlIGZyb20gJ3RydWUtbXl0aC9tYXliZSc7XG5cbiAgLy8gWW91IGNhbiBpbWFnaW5lIHRoYXQgc29tZU90aGVyVmFsdWUgbWlnaHQgYmUgZHluYW1pYy5cbiAgY29uc3Qgc29tZU90aGVyVmFsdWUgPSA5OTtcbiAgY29uc3QgaGFuZGxlTm90aGluZyA9ICgpID0+IHNvbWVPdGhlclZhbHVlO1xuXG4gIGNvbnN0IGFKdXN0ID0gTWF5YmUuanVzdCg0Mik7XG4gIGNvbnNvbGUubG9nKE1heWJlLnVud3JhcE9yRWxzZShoYW5kbGVOb3RoaW5nLCBhSnVzdCkpOyAgLy8gNDJcblxuICBjb25zdCBhTm90aGluZyA9IG5vdGhpbmc8bnVtYmVyPigpO1xuICBjb25zb2xlLmxvZyhNYXliZS51bndyYXBPckVsc2UoaGFuZGxlTm90aGluZywgYU5vdGhpbmcpKTsgLy8gOTlcbiAgYGBgXG5cbiAgQHR5cGVwYXJhbSBUICBUaGUgd3JhcHBlZCB2YWx1ZS5cbiAgQHBhcmFtIG9yRWxzZUZuIEEgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSBhIHZhbGlkIHZhbHVlIGlmIGBtYXliZWAgaXMgYVxuICAgICAgICAgICAgICAgICAgYE5vdGhpbmdgLlxuICBAcGFyYW0gbWF5YmUgICAgVGhlIGBNYXliZWAgaW5zdGFuY2UgdG8gdW53cmFwIGlmIGl0IGlzIGEgYEp1c3RgXG4gIEByZXR1cm5zICAgICAgICBFaXRoZXIgdGhlIGNvbnRlbnQgb2YgYG1heWJlYCBvciB0aGUgdmFsdWUgcmV0dXJuZWQgZnJvbVxuICAgICAgICAgICAgICAgICAgYG9yRWxzZUZuYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVud3JhcE9yRWxzZTxUPihvckVsc2VGbjogKCkgPT4gVCwgbWF5YmU6IE1heWJlPFQ+KTogVDtcbmV4cG9ydCBmdW5jdGlvbiB1bndyYXBPckVsc2U8VD4ob3JFbHNlRm46ICgpID0+IFQpOiAobWF5YmU6IE1heWJlPFQ+KSA9PiBUO1xuZXhwb3J0IGZ1bmN0aW9uIHVud3JhcE9yRWxzZTxUPihvckVsc2VGbjogKCkgPT4gVCwgbWF5YmU/OiBNYXliZTxUPik6IFQgfCAoKG1heWJlOiBNYXliZTxUPikgPT4gVCkge1xuICBjb25zdCBvcCA9IChtOiBNYXliZTxUPikgPT4gKG0uaXNKdXN0KCkgPyBtLnZhbHVlIDogb3JFbHNlRm4oKSk7XG4gIHJldHVybiBjdXJyeTEob3AsIG1heWJlKTtcbn1cblxuLyoqIEFsaWFzIGZvciBbYHVud3JhcE9yRWxzZWBdKCN1bndyYXBvcmVsc2UpICovXG5leHBvcnQgY29uc3QgZ2V0T3JFbHNlID0gdW53cmFwT3JFbHNlO1xuXG4vKipcbiAgVHJhbnNmb3JtIHRoZSBbYE1heWJlYF0oI21heWJlKSBpbnRvIGFcbiAgW2BSZXN1bHRgXSguLi9tb2R1bGVzL19yZXN1bHRfLmh0bWwjcmVzdWx0KSwgdXNpbmcgdGhlIHdyYXBwZWQgdmFsdWUgYXMgdGhlXG4gIGBPa2AgdmFsdWUgaWYgYEp1c3RgOyBvdGhlcndpc2UgdXNpbmcgdGhlIHN1cHBsaWVkIGBlcnJvcmAgdmFsdWUgZm9yIGBFcnJgLlxuXG4gIEB0eXBlcGFyYW0gVCAgVGhlIHdyYXBwZWQgdmFsdWUuXG4gIEB0eXBlcGFyYW0gRSAgVGhlIGVycm9yIHR5cGUgdG8gaW4gdGhlIGBSZXN1bHRgLlxuICBAcGFyYW0gZXJyb3IgVGhlIGVycm9yIHZhbHVlIHRvIHVzZSBpZiB0aGUgYE1heWJlYCBpcyBgTm90aGluZ2AuXG4gIEBwYXJhbSBtYXliZSBUaGUgYE1heWJlYCBpbnN0YW5jZSB0byBjb252ZXJ0LlxuICBAcmV0dXJucyAgICAgQSBgUmVzdWx0YCBjb250YWluaW5nIHRoZSB2YWx1ZSB3cmFwcGVkIGluIGBtYXliZWAgaW4gYW4gYE9rYCxcbiAgICAgICAgICAgICAgIG9yIGBlcnJvcmAgaW4gYW4gYEVycmAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b09rT3JFcnI8VCwgRT4oZXJyb3I6IEUsIG1heWJlOiBNYXliZTxUPik6IFJlc3VsdDxULCBFPjtcbmV4cG9ydCBmdW5jdGlvbiB0b09rT3JFcnI8VCwgRT4oZXJyb3I6IEUpOiAobWF5YmU6IE1heWJlPFQ+KSA9PiBSZXN1bHQ8VCwgRT47XG5leHBvcnQgZnVuY3Rpb24gdG9Pa09yRXJyPFQsIEU+KFxuICBlcnJvcjogRSxcbiAgbWF5YmU/OiBNYXliZTxUPlxuKTogUmVzdWx0PFQsIEU+IHwgKChtYXliZTogTWF5YmU8VD4pID0+IFJlc3VsdDxULCBFPikge1xuICBjb25zdCBvcCA9IChtOiBNYXliZTxUPikgPT4gKG0uaXNKdXN0KCkgPyBvazxULCBFPihtLnZhbHVlKSA6IGVycjxULCBFPihlcnJvcikpO1xuICByZXR1cm4gbWF5YmUgIT09IHVuZGVmaW5lZCA/IG9wKG1heWJlKSA6IG9wO1xufVxuXG4vKipcbiAgVHJhbnNmb3JtIHRoZSBbYE1heWJlYF0oI21heWJlKSBpbnRvIGFcbiAgW2BSZXN1bHRgXSguLi9tb2R1bGVzL19yZXN1bHRfLmh0bWwjcmVzdWx0KSwgdXNpbmcgdGhlIHdyYXBwZWQgdmFsdWUgYXMgdGhlXG4gIGBPa2AgdmFsdWUgaWYgYEp1c3RgOyBvdGhlcndpc2UgdXNpbmcgYGVsc2VGbmAgdG8gZ2VuZXJhdGUgYEVycmAuXG5cbiAgQHR5cGVwYXJhbSBUICBUaGUgd3JhcHBlZCB2YWx1ZS5cbiAgQHR5cGVwYXJhbSBFICBUaGUgZXJyb3IgdHlwZSB0byBpbiB0aGUgYFJlc3VsdGAuXG4gIEBwYXJhbSBlbHNlRm4gVGhlIGZ1bmN0aW9uIHdoaWNoIGdlbmVyYXRlcyBhbiBlcnJvciBvZiB0eXBlIGBFYC5cbiAgQHBhcmFtIG1heWJlICBUaGUgYE1heWJlYCBpbnN0YW5jZSB0byBjb252ZXJ0LlxuICBAcmV0dXJucyAgICAgQSBgUmVzdWx0YCBjb250YWluaW5nIHRoZSB2YWx1ZSB3cmFwcGVkIGluIGBtYXliZWAgaW4gYW4gYE9rYCxcbiAgICAgICAgICAgICAgIG9yIHRoZSB2YWx1ZSBnZW5lcmF0ZWQgYnkgYGVsc2VGbmAgaW4gYW4gYEVycmAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b09rT3JFbHNlRXJyPFQsIEU+KGVsc2VGbjogKCkgPT4gRSwgbWF5YmU6IE1heWJlPFQ+KTogUmVzdWx0PFQsIEU+O1xuZXhwb3J0IGZ1bmN0aW9uIHRvT2tPckVsc2VFcnI8VCwgRT4oZWxzZUZuOiAoKSA9PiBFKTogKG1heWJlOiBNYXliZTxUPikgPT4gUmVzdWx0PFQsIEU+O1xuZXhwb3J0IGZ1bmN0aW9uIHRvT2tPckVsc2VFcnI8VCwgRT4oXG4gIGVsc2VGbjogKCkgPT4gRSxcbiAgbWF5YmU/OiBNYXliZTxUPlxuKTogUmVzdWx0PFQsIEU+IHwgKChtYXliZTogTWF5YmU8VD4pID0+IFJlc3VsdDxULCBFPikge1xuICBjb25zdCBvcCA9IChtOiBNYXliZTxUPikgPT4gKG0uaXNKdXN0KCkgPyBvazxULCBFPihtLnZhbHVlKSA6IGVycjxULCBFPihlbHNlRm4oKSkpO1xuICByZXR1cm4gY3VycnkxKG9wLCBtYXliZSk7XG59XG5cbi8qKlxuICBDb25zdHJ1Y3QgYSBgTWF5YmU8VD5gIGZyb20gYSBgUmVzdWx0PFQsIEU+YC5cblxuICBJZiB0aGUgYFJlc3VsdGAgaXMgYW4gYE9rYCwgd3JhcCBpdHMgdmFsdWUgaW4gYEp1c3RgLiBJZiB0aGUgYFJlc3VsdGAgaXMgYW5cbiAgYEVycmAsIHRocm93IGF3YXkgdGhlIHdyYXBwZWQgYEVgIGFuZCB0cmFuc2Zvcm0gdG8gYSBgTm90aGluZ2AuXG5cbiAgQHR5cGVwYXJhbSBUICBUaGUgdHlwZSBvZiB0aGUgdmFsdWUgd3JhcHBlZCBpbiBhIGBSZXN1bHQuT2tgIGFuZCBpbiB0aGUgYEp1c3RgXG4gICAgICAgICAgICAgICAgb2YgdGhlIHJlc3VsdGluZyBgTWF5YmVgLlxuICBAdHlwZXBhcmFtIEUgIFRoZSB0eXBlIG9mIHRoZSB2YWx1ZSB3cmFwcGVkIGluIGEgYFJlc3VsdC5FcnJgOyB0aHJvd24gYXdheSBpblxuICAgICAgICAgICAgICAgIHRoZSByZXN1bHRpbmcgYE1heWJlYC5cbiAgQHBhcmFtIHJlc3VsdCBUaGUgYFJlc3VsdGAgdG8gY29uc3RydWN0IGEgYE1heWJlYCBmcm9tLlxuICBAcmV0dXJucyAgICAgIGBKdXN0YCBpZiBgcmVzdWx0YCB3YXMgYE9rYCBvciBgTm90aGluZ2AgaWYgaXQgd2FzIGBFcnJgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJlc3VsdDxUPihyZXN1bHQ6IFJlc3VsdDxULCBhbnk+KTogTWF5YmU8VD4ge1xuICByZXR1cm4gcmVzdWx0LmlzT2soKSA/IGp1c3QocmVzdWx0LnZhbHVlKSA6IG5vdGhpbmc8VD4oKTtcbn1cblxuLyoqXG4gIENyZWF0ZSBhIGBTdHJpbmdgIHJlcHJlc2VudGF0aW9uIG9mIGEgYE1heWJlYCBpbnN0YW5jZS5cblxuICBBIGBKdXN0YCBpbnN0YW5jZSB3aWxsIGJlIHByaW50ZWQgYXMgYEp1c3QoPHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2YWx1ZT4pYCxcbiAgd2hlcmUgdGhlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2YWx1ZSBpcyBzaW1wbHkgdGhlIHZhbHVlJ3Mgb3duIGB0b1N0cmluZ2BcbiAgcmVwcmVzZW50YXRpb24uIEZvciBleGFtcGxlOlxuXG4gIHwgY2FsbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBvdXRwdXQgICAgICAgICAgICAgICAgICB8XG4gIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gIHwgYHRvU3RyaW5nKE1heWJlLm9mKDQyKSlgICAgICAgICAgICAgICAgfCBgSnVzdCg0MilgICAgICAgICAgICAgICB8XG4gIHwgYHRvU3RyaW5nKE1heWJlLm9mKFsxLCAyLCAzXSkpYCAgICAgICAgfCBgSnVzdCgxLDIsMylgICAgICAgICAgICB8XG4gIHwgYHRvU3RyaW5nKE1heWJlLm9mKHsgYW46ICdvYmplY3QnIH0pKWAgfCBgSnVzdChbb2JqZWN0IE9iamVjdF0pYCB8XG4gIHwgYHRvU3RyaW5nKE1heWJlLm5vdGhpbmcoKSlgICAgICAgICAgICAgfCBgTm90aGluZ2AgICAgICAgICAgICAgICB8XG5cbiAgQHR5cGVwYXJhbSBUIFRoZSB0eXBlIG9mIHRoZSB3cmFwcGVkIHZhbHVlOyBpdHMgb3duIGAudG9TdHJpbmdgIHdpbGwgYmUgdXNlZFxuICAgICAgICAgICAgICAgdG8gcHJpbnQgdGhlIGludGVyaW9yIGNvbnRlbnRzIG9mIHRoZSBgSnVzdGAgdmFyaWFudC5cbiAgQHBhcmFtIG1heWJlIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGEgc3RyaW5nLlxuICBAcmV0dXJucyAgICAgVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgYE1heWJlYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvU3RyaW5nPFQ+KG1heWJlOiBNYXliZTxUPik6IHN0cmluZyB7XG4gIGNvbnN0IGJvZHkgPSBtYXliZS5pc0p1c3QoKSA/IGAoJHttYXliZS52YWx1ZS50b1N0cmluZygpfSlgIDogJyc7XG4gIHJldHVybiBgJHttYXliZS52YXJpYW50fSR7Ym9keX1gO1xufVxuXG4vKiogQSBsaWdodHdlaWdodCBvYmplY3QgZGVmaW5pbmcgaG93IHRvIGhhbmRsZSBlYWNoIHZhcmlhbnQgb2YgYSBNYXliZS4gKi9cbmV4cG9ydCB0eXBlIE1hdGNoZXI8VCwgQT4gPSB7XG4gIEp1c3Q6ICh2YWx1ZTogVCkgPT4gQTtcbiAgTm90aGluZzogKCkgPT4gQTtcbn07XG5cbi8qKlxuICBQZXJmb3JtcyB0aGUgc2FtZSBiYXNpYyBmdW5jdGlvbmFsaXR5IGFzIGBnZXRPckVsc2VgLCBidXQgaW5zdGVhZCBvZiBzaW1wbHlcbiAgdW53cmFwcGluZyB0aGUgdmFsdWUgaWYgaXQgaXMgYEp1c3RgIGFuZCBhcHBseWluZyBhIHZhbHVlIHRvIGdlbmVyYXRlIHRoZSBzYW1lXG4gIGRlZmF1bHQgdHlwZSBpZiBpdCBpcyBgTm90aGluZ2AsIGxldHMgeW91IHN1cHBseSBmdW5jdGlvbnMgd2hpY2ggbWF5IHRyYW5zZm9ybVxuICB0aGUgd3JhcHBlZCB0eXBlIGlmIGl0IGlzIGBKdXN0YCBvciBnZXQgYSBkZWZhdWx0IHZhbHVlIGZvciBgTm90aGluZ2AuXG5cbiAgVGhpcyBpcyBraW5kIG9mIGxpa2UgYSBwb29yIG1hbidzIHZlcnNpb24gb2YgcGF0dGVybiBtYXRjaGluZywgd2hpY2hcbiAgSmF2YVNjcmlwdCBjdXJyZW50bHkgbGFja3MuXG5cbiAgSW5zdGVhZCBvZiBjb2RlIGxpa2UgdGhpczpcblxuICBgYGB0c1xuICBpbXBvcnQgTWF5YmUgZnJvbSAndHJ1ZS1teXRoL21heWJlJztcblxuICBjb25zdCBsb2dWYWx1ZSA9IChtaWdodEJlQU51bWJlcjogTWF5YmU8bnVtYmVyPikgPT4ge1xuICAgIGNvbnN0IHZhbHVlVG9Mb2cgPSBNYXliZS5taWdodEJlQU51bWJlci5pc0p1c3QoKVxuICAgICAgPyBNYXliZS51bnNhZmVseVVud3JhcChtaWdodEJlQU51bWJlcikudG9TdHJpbmcoKVxuICAgICAgOiAnTm90aGluZyB0byBsb2cuJztcblxuICAgIGNvbnNvbGUubG9nKHZhbHVlVG9Mb2cpO1xuICB9O1xuICBgYGBcblxuICAuLi53ZSBjYW4gd3JpdGUgY29kZSBsaWtlIHRoaXM6XG5cbiAgYGBgdHNcbiAgaW1wb3J0IE1heWJlIGZyb20gJ3RydWUtbXl0aC9tYXliZSc7XG5cbiAgY29uc3QgbG9nVmFsdWUgPSAobWlnaHRCZUFOdW1iZXI6IE1heWJlPG51bWJlcj4pID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IE1heWJlLm1hdGNoKFxuICAgICAge1xuICAgICAgICBKdXN0OiBuID0+IG4udG9TdHJpbmcoKSxcbiAgICAgICAgTm90aGluZzogKCkgPT4gJ05vdGhpbmcgdG8gbG9nLicsXG4gICAgICB9LFxuICAgICAgbWlnaHRCZUFOdW1iZXJcbiAgICApO1xuXG4gICAgY29uc29sZS5sb2codmFsdWUpO1xuICB9O1xuICBgYGBcblxuICBUaGlzIGlzIHNsaWdodGx5IGxvbmdlciB0byB3cml0ZSwgYnV0IGNsZWFyZXI6IHRoZSBtb3JlIGNvbXBsZXggdGhlIHJlc3VsdGluZ1xuICBleHByZXNzaW9uLCB0aGUgaGFpcmVyIGl0IGlzIHRvIHVuZGVyc3RhbmQgdGhlIHRlcm5hcnkuIFRodXMsIHRoaXMgaXNcbiAgZXNwZWNpYWxseSBjb252ZW5pZW50IGZvciB0aW1lcyB3aGVuIHRoZXJlIGlzIGEgY29tcGxleCByZXN1bHQsIGUuZy4gd2hlblxuICByZW5kZXJpbmcgcGFydCBvZiBhIFJlYWN0IGNvbXBvbmVudCBpbmxpbmUgaW4gSlNYL1RTWC5cblxuICBAcGFyYW0gbWF0Y2hlciBBIGxpZ2h0d2VpZ2h0IG9iamVjdCBkZWZpbmluZyB3aGF0IHRvIGRvIGluIHRoZSBjYXNlIG9mIGVhY2hcbiAgICAgICAgICAgICAgICAgdmFyaWFudC5cbiAgQHBhcmFtIG1heWJlICAgVGhlIGBtYXliZWAgaW5zdGFuY2UgdG8gY2hlY2suXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaDxULCBBPihtYXRjaGVyOiBNYXRjaGVyPFQsIEE+LCBtYXliZTogTWF5YmU8VD4pOiBBO1xuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoPFQsIEE+KG1hdGNoZXI6IE1hdGNoZXI8VCwgQT4pOiAobTogTWF5YmU8VD4pID0+IEE7XG5leHBvcnQgZnVuY3Rpb24gbWF0Y2g8VCwgQT4obWF0Y2hlcjogTWF0Y2hlcjxULCBBPiwgbWF5YmU/OiBNYXliZTxUPik6IEEgfCAoKG06IE1heWJlPFQ+KSA9PiBBKSB7XG4gIHJldHVybiBtYXliZSAhPT0gdW5kZWZpbmVkXG4gICAgPyBtYXBPckVsc2UobWF0Y2hlci5Ob3RoaW5nLCBtYXRjaGVyLkp1c3QsIG1heWJlKVxuICAgIDogKGN1cnJpZWRNYXliZTogTWF5YmU8VD4pID0+IG1hcE9yRWxzZShtYXRjaGVyLk5vdGhpbmcsIG1hdGNoZXIuSnVzdCwgY3VycmllZE1heWJlKTtcbn1cblxuLyoqIEFsaWFzIGZvciBbYG1hdGNoYF0oI21hdGNoKSAqL1xuZXhwb3J0IGNvbnN0IGNhdGEgPSBtYXRjaDtcblxuLyoqXG4gIEFsbG93cyBxdWljayB0cmlwbGUtZXF1YWwgZXF1YWxpdHkgY2hlY2sgYmV0d2VlbiB0aGUgdmFsdWVzIGluc2lkZSB0d28gYG1heWJlYHNcbiAgd2l0aG91dCBoYXZpbmcgdG8gdW53cmFwIHRoZW0gZmlyc3QuXG5cbiAgYGBgdHNcbiAgY29uc3QgYSA9IE1heWJlLm9mKDMpO1xuICBjb25zdCBiID0gTWF5YmUub2YoMyk7XG4gIGNvbnN0IGMgPSBNYXliZS5vZihudWxsKTtcbiAgY29uc3QgZCA9IE1heWJlLm5vdGhpbmcoKTtcblxuICBNYXliZS5lcXVhbHMoYSwgYik7IC8vIHRydWVcbiAgTWF5YmUuZXF1YWxzKGEsIGMpOyAvLyBmYWxzZVxuICBNYXliZS5lcXVhbHMoYywgZCk7IC8vIHRydWVcbiAgYGBgXG5cbiAgQHBhcmFtIG1iIEEgYG1heWJlYCB0byBjb21wYXJlIHRvLlxuICBAcGFyYW0gbWEgQSBgbWF5YmVgIGluc3RhbmNlIHRvIGNoZWNrLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzPFQ+KG1iOiBNYXliZTxUPiwgbWE6IE1heWJlPFQ+KTogYm9vbGVhbjtcbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHM8VD4obWI6IE1heWJlPFQ+KTogKG1hOiBNYXliZTxUPikgPT4gYm9vbGVhbjtcbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHM8VD4obWI6IE1heWJlPFQ+LCBtYT86IE1heWJlPFQ+KTogYm9vbGVhbiB8ICgoYTogTWF5YmU8VD4pID0+IGJvb2xlYW4pIHtcbiAgcmV0dXJuIG1hICE9PSB1bmRlZmluZWRcbiAgICA/IG1hLm1hdGNoKHtcbiAgICAgICAgSnVzdDogYVZhbCA9PiBtYi5pc0p1c3QoKSAmJiBtYi51bnNhZmVseVVud3JhcCgpID09PSBhVmFsLFxuICAgICAgICBOb3RoaW5nOiAoKSA9PiBpc05vdGhpbmcobWIpLFxuICAgICAgfSlcbiAgICA6IChtYXliZUE6IE1heWJlPFQ+KSA9PlxuICAgICAgICBtYXliZUEubWF0Y2goe1xuICAgICAgICAgIE5vdGhpbmc6ICgpID0+IGlzTm90aGluZyhtYiksXG4gICAgICAgICAgSnVzdDogYVZhbCA9PiBtYi5pc0p1c3QoKSAmJiBtYi51bnNhZmVseVVud3JhcCgpID09PSBhVmFsLFxuICAgICAgICB9KTtcbn1cblxuLyoqXG4gIEFsbG93cyB5b3UgdG8gKmFwcGx5KiAodGh1cyBgYXBgKSBhIHZhbHVlIHRvIGEgZnVuY3Rpb24gd2l0aG91dCBoYXZpbmcgdG9cbiAgdGFrZSBlaXRoZXIgb3V0IG9mIHRoZSBjb250ZXh0IG9mIHRoZWlyIGBNYXliZWBzLiBUaGlzIGRvZXMgbWVhbiB0aGF0IHRoZVxuICB0cmFuc2Zvcm1pbmcgZnVuY3Rpb24gaXMgaXRzZWxmIHdpdGhpbiBhIGBNYXliZWAsIHdoaWNoIGNhbiBiZSBoYXJkIHRvIGdyb2tcbiAgYXQgZmlyc3QgYnV0IGxldHMgeW91IGRvIHNvbWUgdmVyeSBlbGVnYW50IHRoaW5ncy4gRm9yIGV4YW1wbGUsIGBhcGAgYWxsb3dzXG4gIHlvdSB0byB0aGlzOlxuXG4gIGBgYHRzXG4gIGltcG9ydCB7IGp1c3QsIG5vdGhpbmcgfSBmcm9tICd0cnVlLW15dGgvbWF5YmUnO1xuXG4gIGNvbnN0IG9uZSA9IGp1c3QoMSk7XG4gIGNvbnN0IGZpdmUgPSBqdXN0KDUpO1xuICBjb25zdCBub25lID0gbm90aGluZygpO1xuXG4gIGNvbnN0IGFkZCA9IChhOiBudW1iZXIpID0+IChiOiBudW1iZXIpID0+IGEgKyBiO1xuICBjb25zdCBtYXliZUFkZCA9IGp1c3QoYWRkKTtcblxuICBtYXliZUFkZC5hcChvbmUpLmFwKGZpdmUpOyAvLyBKdXN0KDYpXG4gIG1heWJlQWRkLmFwKG9uZSkuYXAobm9uZSk7IC8vIE5vdGhpbmdcbiAgbWF5YmVBZGQuYXAobm9uZSkuYXAoZml2ZSkgLy8gTm90aGluZ1xuICBgYGBcblxuICBXaXRob3V0IGBNYXliZS5hcGAsIHlvdSdkIG5lZWQgdG8gZG8gc29tZXRoaW5nIGxpa2UgYSBuZXN0ZWQgYE1heWJlLm1hdGNoYDpcblxuICBgYGB0c1xuICBpbXBvcnQgeyBqdXN0LCBub3RoaW5nIH0gZnJvbSAndHJ1ZS1teXRoL21heWJlJztcblxuICBjb25zdCBvbmUgPSBqdXN0KDEpO1xuICBjb25zdCBmaXZlID0ganVzdCg1KTtcbiAgY29uc3Qgbm9uZSA9IG5vdGhpbmcoKTtcblxuICBvbmUubWF0Y2goe1xuICAgIEp1c3Q6IG4gPT4gZml2ZS5tYXRjaCh7XG4gICAgICBKdXN0OiBvID0+IGp1c3QobiArIG8pLFxuICAgICAgTm90aGluZzogKCkgPT4gbm90aGluZygpLFxuICAgIH0pLFxuICAgIE5vdGhpbmc6ICgpICA9PiBub3RoaW5nKCksXG4gIH0pOyAvLyBKdXN0KDYpXG5cbiAgb25lLm1hdGNoKHtcbiAgICBKdXN0OiBuID0+IG5vbmUubWF0Y2goe1xuICAgICAgSnVzdDogbyA9PiBqdXN0KG4gKyBvKSxcbiAgICAgIE5vdGhpbmc6ICgpID0+IG5vdGhpbmcoKSxcbiAgICB9KSxcbiAgICBOb3RoaW5nOiAoKSAgPT4gbm90aGluZygpLFxuICB9KTsgLy8gTm90aGluZ1xuXG4gIG5vbmUubWF0Y2goe1xuICAgIEp1c3Q6IG4gPT4gZml2ZS5tYXRjaCh7XG4gICAgICBKdXN0OiBvID0+IGp1c3QobiArIG8pLFxuICAgICAgTm90aGluZzogKCkgPT4gbm90aGluZygpLFxuICAgIH0pLFxuICAgIE5vdGhpbmc6ICgpICA9PiBub3RoaW5nKCksXG4gIH0pOyAvLyBOb3RoaW5nXG4gIGBgYFxuXG4gIEFuZCB0aGlzIGtpbmQgb2YgdGhpbmcgY29tZXMgdXAgcXVpdGUgb2Z0ZW4gb25jZSB5b3UncmUgdXNpbmcgYE1heWJlYCB0b1xuICBoYW5kbGUgb3B0aW9uYWxpdHkgdGhyb3VnaG91dCB5b3VyIGFwcGxpY2F0aW9uLlxuXG4gIEZvciBhbm90aGVyIGV4YW1wbGUsIGltYWdpbmUgeW91IG5lZWQgdG8gY29tcGFyZSB0aGUgZXF1YWxpdHkgb2YgdHdvXG4gIEltbXV0YWJsZUpTIGRhdGEgc3RydWN0dXJlcywgd2hlcmUgYSBgPT09YCBjb21wYXJpc29uIHdvbid0IHdvcmsuIFdpdGggYGFwYCxcbiAgdGhhdCdzIGFzIHNpbXBsZSBhcyB0aGlzOlxuXG4gIGBgYHRzXG4gIGltcG9ydCBNYXliZSBmcm9tICd0cnVlLW15dGgvbWF5YmUnO1xuICBpbXBvcnQgSW1tdXRhYmxlIGZyb20gJ2ltbXV0YWJsZSc7XG4gIGltcG9ydCB7IGN1cnJ5IH0gZnJvbSAnbG9kYXNoJ1xuXG4gIGNvbnN0IGlzID0gY3VycnkoSW1tdXRhYmxlLmlzKTtcblxuICBjb25zdCB4ID0gTWF5YmUub2YoSW1tdXRhYmxlLlNldC5vZigxLCAyLCAzKSk7XG4gIGNvbnN0IHkgPSBNYXliZS5vZihJbW11dGFibGUuU2V0Lm9mKDIsIDMsIDQpKTtcblxuICBNYXliZS5vZihpcykuYXAoeCkuYXAoeSk7IC8vIEp1c3QoZmFsc2UpXG4gIGBgYFxuXG4gIFdpdGhvdXQgYGFwYCwgd2UncmUgYmFjayB0byB0aGF0IGduYXJseSBuZXN0ZWQgYG1hdGNoYDpcblxuICBgYGB0c1xuICAgKiBpbXBvcnQgTWF5YmUsIHsganVzdCwgbm90aGluZyB9IGZyb20gJ3RydWUtbXl0aC9tYXliZSc7XG4gIGltcG9ydCBJbW11dGFibGUgZnJvbSAnaW1tdXRhYmxlJztcbiAgaW1wb3J0IHsgY3VycnkgfSBmcm9tICdsb2Rhc2gnXG5cbiAgY29uc3QgaXMgPSBjdXJyeShJbW11dGFibGUuaXMpO1xuXG4gIGNvbnN0IHggPSBNYXliZS5vZihJbW11dGFibGUuU2V0Lm9mKDEsIDIsIDMpKTtcbiAgY29uc3QgeSA9IE1heWJlLm9mKEltbXV0YWJsZS5TZXQub2YoMiwgMywgNCkpO1xuXG4gIHgubWF0Y2goe1xuICAgIEp1c3Q6IGlYID0+IHkubWF0Y2goe1xuICAgICAgSnVzdDogaVkgPT4gTWF5YmUuanVzdChJbW11dGFibGUuaXMoaVgsIGlZKSksXG4gICAgICBOb3RoaW5nOiAoKSA9PiBNYXliZS5ub3RoaW5nKCksXG4gICAgfSlcbiAgICBOb3RoaW5nOiAoKSA9PiBNYXliZS5ub3RoaW5nKCksXG4gIH0pOyAvLyBKdXN0KGZhbHNlKVxuICBgYGBcblxuICBJbiBzdW1tYXJ5OiBhbnl3aGVyZSB5b3UgaGF2ZSB0d28gYE1heWJlYCBpbnN0YW5jZXMgYW5kIG5lZWQgdG8gcGVyZm9ybSBhblxuICBvcGVyYXRpb24gdGhhdCB1c2VzIGJvdGggb2YgdGhlbSwgYGFwYCBpcyB5b3VyIGZyaWVuZC5cblxuICBUd28gdGhpbmdzIHRvIG5vdGUsIGJvdGggcmVnYXJkaW5nICpjdXJyeWluZyo6XG5cbiAgMS4gIEFsbCBmdW5jdGlvbnMgcGFzc2VkIHRvIGBhcGAgbXVzdCBiZSBjdXJyaWVkLiBUaGF0IGlzLCB0aGV5IG11c3QgYmUgb2YgdGhlXG4gICAgICBmb3JtIChmb3IgYWRkKSBgKGE6IG51bWJlcikgPT4gKGI6IG51bWJlcikgPT4gYSArIGJgLCAqbm90KiB0aGUgbW9yZSB1c3VhbFxuICAgICAgYChhOiBudW1iZXIsIGI6IG51bWJlcikgPT4gYSArIGJgIHlvdSBzZWUgaW4gSmF2YVNjcmlwdCBtb3JlIGdlbmVyYWxseS5cblxuICAgICAgRm9yIGNvbnZlbmllbmNlLCB5b3UgbWF5IHdhbnQgdG8gbG9vayBhdCBMb2Rhc2gncyBgXy5jdXJyeWAgb3IgUmFtZGEnc1xuICAgICAgYFIuY3VycnlgLCB3aGljaCBhbGxvdyB5b3UgdG8gY3JlYXRlIGN1cnJpZWQgdmVyc2lvbnMgb2YgZnVuY3Rpb25zXG4gICAgICB3aGVuZXZlciB5b3Ugd2FudDpcblxuICAgICAgYGBgXG4gICAgICBpbXBvcnQgTWF5YmUgZnJvbSAndHJ1ZS1teXRoL21heWJlJztcbiAgICAgIGltcG9ydCB7IGN1cnJ5IH0gZnJvbSAnbG9kYXNoJztcblxuICAgICAgY29uc3Qgbm9ybWFsQWRkID0gKGE6IG51bWJlciwgYjogbnVtYmVyKSA9PiBhICsgYjtcbiAgICAgIGNvbnN0IGN1cnJpZWRBZGQgPSBjdXJyeShub3JtYWxBZGQpOyAvLyAoYTogbnVtYmVyKSA9PiAoYjogbnVtYmVyKSA9PiBhICsgYjtcblxuICAgICAgTWF5YmUub2YoY3VycmllZEFkZCkuYXAoTWF5YmUub2YoMSkpLmFwKE1heWJlLm9mKDUpKTsgLy8gSnVzdCg2KVxuICAgICAgYGBgXG5cbiAgMi4gIFlvdSB3aWxsIG5lZWQgdG8gY2FsbCBgYXBgIGFzIG1hbnkgdGltZXMgYXMgdGhlcmUgYXJlIGFyZ3VtZW50cyB0byB0aGVcbiAgICAgIGZ1bmN0aW9uIHlvdSdyZSBkZWFsaW5nIHdpdGguIFNvIGluIHRoZSBjYXNlIG9mIGBhZGRgLCB3aGljaCBoYXMgdGhlXG4gICAgICBcImFyaXR5XCIgKGZ1bmN0aW9uIGFyZ3VtZW50IGNvdW50KSBvZiAyIChgYWAgYW5kIGBiYCksIHlvdSdsbCBuZWVkIHRvIGNhbGxcbiAgICAgIGBhcGAgdHdpY2U6IG9uY2UgZm9yIGBhYCwgYW5kIG9uY2UgZm9yIGBiYC4gVG8gc2VlIHdoeSwgbGV0J3MgbG9vayBhdCB3aGF0XG4gICAgICB0aGUgcmVzdWx0IGluIGVhY2ggcGhhc2UgaXM6XG5cbiAgICAgIGBgYHRzXG4gICAgICBjb25zdCBhZGQgPSAoYTogbnVtYmVyKSA9PiAoYjogbnVtYmVyKSA9PiBhICsgYjtcblxuICAgICAgY29uc3QgbWF5YmVBZGQgPSBNYXliZS5vZihhZGQpOyAvLyBKdXN0KChhOiBudW1iZXIpID0+IChiOiBudW1iZXIpID0+IGEgKyBiKVxuICAgICAgY29uc3QgbWF5YmVBZGQxID0gbWF5YmVBZGQuYXAoTWF5YmUub2YoMSkpOyAvLyBKdXN0KChiOiBudW1iZXIpID0+IDEgKyBiKVxuICAgICAgY29uc3QgZmluYWwgPSBtYXliZUFkZDEuYXAoTWF5YmUub2YoMykpOyAvLyBKdXN0KDQpXG4gICAgICBgYGBcblxuICAgICAgU28gZm9yIGB0b1N0cmluZ2AsIHdoaWNoIGp1c3QgdGFrZXMgYSBzaW5nbGUgYXJndW1lbnQsIHlvdSB3b3VsZCBvbmx5IG5lZWRcbiAgICAgIHRvIGNhbGwgYGFwYCBvbmNlLlxuXG4gICAgICBgYGB0c1xuICAgICAgY29uc3QgdG9TdHIgPSAodjogeyB0b1N0cmluZygpOiBzdHJpbmcgfSkgPT4gdi50b1N0cmluZygpO1xuICAgICAgTWF5YmUub2YodG9TdHIpLmFwKDEyKTsgLy8gSnVzdChcIjEyXCIpXG4gICAgICBgYGBcblxuICBPbmUgb3RoZXIgc2NlbmFyaW8gd2hpY2ggZG9lc24ndCBjb21lIHVwICpxdWl0ZSogYXMgb2Z0ZW4gYnV0IGlzIGNvbmNlaXZhYmxlXG4gIGlzIHdoZXJlIHlvdSBoYXZlIHNvbWV0aGluZyB0aGF0IG1heSBvciBtYXkgbm90IGFjdHVhbGx5IGNvbnN0cnVjdCBhIGZ1bmN0aW9uXG4gIGZvciBoYW5kbGluZyBhIHNwZWNpZmljIGBNYXliZWAgc2NlbmFyaW8uIEluIHRoYXQgY2FzZSwgeW91IGNhbiB3cmFwIHRoZVxuICBwb3NzaWJseS1wcmVzZW50IGluIGBhcGAgYW5kIHRoZW4gd3JhcCB0aGUgdmFsdWVzIHRvIGFwcGx5IHRvIHRoZSBmdW5jdGlvbiB0b1xuICBpbiBgTWF5YmVgIHRoZW1zZWx2ZXMuXG5cbiAgKipBc2lkZToqKiBgYXBgIGlzIG5vdCBuYW1lZCBgYXBwbHlgIGJlY2F1c2Ugb2YgdGhlIG92ZXJsYXAgd2l0aCBKYXZhU2NyaXB0J3NcbiAgZXhpc3RpbmcgW2BhcHBseWBdIGZ1bmN0aW9uIOKAkyBhbmQgYWx0aG91Z2ggc3RyaWN0bHkgc3BlYWtpbmcsIHRoZXJlIGlzbid0IGFueVxuICBkaXJlY3Qgb3ZlcmxhcCAoYE1heWJlLmFwcGx5YCBhbmQgYEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseWAgZG9uJ3QgaW50ZXJzZWN0XG4gIGF0IGFsbCkgaXQncyB1c2VmdWwgdG8gaGF2ZSBhIGRpZmZlcmVudCBuYW1lIHRvIGF2b2lkIGltcGx5aW5nIHRoYXQgdGhleSdyZVxuICB0aGUgc2FtZS5cblxuICBbYGFwcGx5YF06IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL2FwcGx5XG5cbiAgQHBhcmFtIG1heWJlRm4gbWF5YmUgYSBmdW5jdGlvbiBmcm9tIFQgdG8gVVxuICBAcGFyYW0gbWF5YmUgbWF5YmUgYSBUIHRvIGFwcGx5IHRvIGBmbmBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwPFQsIFU+KG1heWJlRm46IE1heWJlPCh0OiBUKSA9PiBVPiwgbWF5YmU6IE1heWJlPFQ+KTogTWF5YmU8VT47XG5leHBvcnQgZnVuY3Rpb24gYXA8VCwgVT4obWF5YmVGbjogTWF5YmU8KHQ6IFQpID0+IFU+KTogKG1heWJlOiBNYXliZTxUPikgPT4gTWF5YmU8VT47XG5leHBvcnQgZnVuY3Rpb24gYXA8VCwgVT4oXG4gIG1heWJlRm46IE1heWJlPCh2YWw6IFQpID0+IFU+LFxuICBtYXliZT86IE1heWJlPFQ+XG4pOiBNYXliZTxVPiB8ICgodmFsOiBNYXliZTxUPikgPT4gTWF5YmU8VT4pIHtcbiAgY29uc3Qgb3AgPSAobTogTWF5YmU8VD4pID0+XG4gICAgbS5tYXRjaCh7XG4gICAgICBKdXN0OiB2YWwgPT4gbWF5YmVGbi5tYXAoZm4gPT4gZm4odmFsKSksXG4gICAgICBOb3RoaW5nOiAoKSA9PiBNYXliZS5ub3RoaW5nPFU+KCksXG4gICAgfSk7XG5cbiAgcmV0dXJuIGN1cnJ5MShvcCwgbWF5YmUpO1xufVxuXG4vKipcbiAgRGV0ZXJtaW5lIHdoZXRoZXIgYW4gaXRlbSBpcyBhbiBpbnN0YW5jZSBvZiBgSnVzdGAgb3IgYE5vdGhpbmdgLlxuXG4gIEBwYXJhbSBpdGVtIFRoZSBpdGVtIHRvIGNoZWNrLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNJbnN0YW5jZTxUID0gYW55PihpdGVtOiBhbnkpOiBpdGVtIGlzIE1heWJlPFQ+IHtcbiAgcmV0dXJuIGl0ZW0gaW5zdGFuY2VvZiBKdXN0IHx8IGl0ZW0gaW5zdGFuY2VvZiBOb3RoaW5nO1xufVxuXG50eXBlIFByZWRpY2F0ZTxUPiA9IChlbGVtZW50OiBULCBpbmRleDogbnVtYmVyLCBhcnJheTogVFtdKSA9PiBib29sZWFuO1xuXG4vLyBOT1RFOiBkb2N1bWVudGF0aW9uIGlzIGxpZ2h0bHkgYWRhcHRlZCBmcm9tIHRoZSBNRE4gYW5kIFR5cGVTY3JpcHQgZG9jcyBmb3Jcbi8vIGBBcnJheS5wcm90b3R5cGUuZmluZGAuXG4vKipcbiAgU2FmZWx5IHNlYXJjaCBmb3IgYW4gZWxlbWVudCBpbiBhbiBhcnJheS5cbiAgXG4gIFRoaXMgZnVuY3Rpb24gYmVoYXZlcyBsaWtlIGBBcnJheS5wcm90b3R5cGUuZmluZGAsIGJ1dCByZXR1cm5zIGBNYXliZTxUPmBcbiAgaW5zdGVhZCBvZiBgVCB8IHVuZGVmaW5lZGAuXG4gIFxuICAjIyBFeGFtcGxlc1xuXG4gIFRoZSBiYXNpYyBmb3JtIGlzOlxuXG4gIGBgYHRzXG4gIGltcG9ydCBNYXliZSBmcm9tICd0cnVlLW15dGgvbWF5YmUnO1xuXG4gIGxldCBhcnJheSA9IFsxLCAyLCAzXTtcbiAgTWF5YmUuZmluZCh2ID0+IHYgPiAxLCBhcnJheSk7IC8vIEp1c3QoMilcbiAgTWF5YmUuZmluZCh2ID0+IHYgPCAxLCBhcnJheSk7IC8vIE5vdGhpbmdcbiAgYGBgXG5cbiAgVGhlIGZ1bmN0aW9uIGlzIGN1cnJpZWQgc28geW91IGNhbiB1c2UgaXQgaW4gYSBmdW5jdGlvbmFsIGNoYWluLiBGb3IgZXhhbXBsZVxuICAobGVhdmluZyBhc2lkZSBlcnJvciBoYW5kbGluZyBvbiBhIGJhZCByZXNwb25zZSBmb3Igc2ltcGxpY2l0eSksIHN1cHBvc2UgdGhlXG4gIHVybCBgaHR0cHM6Ly9hcnJheXMuZXhhbXBsZS5jb21gIHJldHVybmVkIGEgSlNPTiBwYXlsb2FkIHdpdGggdGhlIHR5cGVcbiAgYEFycmF5PHsgY291bnQ6IG51bWJlciwgbmFtZTogc3RyaW5nIH0+YCwgYW5kIHdlIHdhbnRlZCB0byBnZXQgdGhlIGZpcnN0XG4gIG9mIHRoZXNlIHdoZXJlIGBjb3VudGAgd2FzIGF0IGxlYXN0IDEwMC4gV2UgY291bGQgd3JpdGUgdGhpczpcblxuICBgYGB0c1xuICBpbXBvcnQgTWF5YmUgZnJvbSAndHJ1ZS1teXRoL21heWJlJztcblxuICB0eXBlIEl0ZW0gPSB7IGNvdW50OiBudW1iZXI7IG5hbWU6IHN0cmluZyB9O1xuICB0eXBlIFJlc3BvbnNlID0gQXJyYXk8SXRlbT47XG5cbiAgLy8gY3VycmllZCB2YXJpYW50IVxuICBjb25zdCBmaW5kQXRMZWFzdDEwMCA9IE1heWJlLmZpbmQoKHsgY291bnQgfTogSXRlbSkgPT4gY291bnQgPiAxMDApO1xuXG4gIGZldGNoKCdodHRwczovL2FycmF5cy5leGFtcGxlLmNvbScpXG4gICAgLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuanNvbigpIGFzIFJlc3BvbnNlKVxuICAgIC50aGVuKGZpbmRBdExlYXN0MTAwKVxuICAgIC50aGVuKGZvdW5kID0+IHtcbiAgICAgIGlmIChmb3VuZC5pc0p1c3QoKSkge1xuICAgICAgICBjb25zb2xlLmxvZyhgVGhlIG1hdGNoaW5nIHZhbHVlIGlzICR7Zm91bmQudmFsdWUubmFtZX0hYCk7XG4gICAgICB9XG4gICAgfSk7XG4gIGBgYFxuICBcbiAgQHBhcmFtIHByZWRpY2F0ZSAgQSBmdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggdmFsdWUgaW4gdGhlIGFycmF5LCByZXR1cm5pbmdcbiAgICAgICAgICAgICAgICAgICAgYHRydWVgIHdoZW4gdGhlIGl0ZW0gaW4gdGhlIGFycmF5IG1hdGNoZXMgdGhlIGNvbmRpdGlvbi4gVGhlXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZSBmb3IgYHByZWRpY2F0ZWAgaXMgaWRlbnRpY2FsIHRvIHRoZSBzaWduYXR1cmUgZm9yXG4gICAgICAgICAgICAgICAgICAgIHRoZSBmaXJzdCBhcmd1bWVudCB0byBgQXJyYXkucHJvdG90eXBlLmZpbmRgLiBUaGUgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgaXMgY2FsbGVkIG9uY2UgZm9yIGVhY2ggZWxlbWVudCBvZiB0aGUgYXJyYXksIGluIGFzY2VuZGluZ1xuICAgICAgICAgICAgICAgICAgICBvcmRlciwgdW50aWwgaXQgZmluZHMgb25lIHdoZXJlIHByZWRpY2F0ZSByZXR1cm5zIHRydWUuIElmXG4gICAgICAgICAgICAgICAgICAgIHN1Y2ggYW4gZWxlbWVudCBpcyBmb3VuZCwgZmluZCBpbW1lZGlhdGVseSByZXR1cm5zIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCB2YWx1ZSB3cmFwcGVkIGluIGBKdXN0YC4gT3RoZXJ3aXNlLCBgTWF5YmUuZmluZGBcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJucyBgTm90aGluZ2AuXG4gKiBAcGFyYW0gYXJyYXkgICAgIFRoZSBhcnJheSB0byBzZWFyY2ggdXNpbmcgdGhlIHByZWRpY2F0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmQ8VD4ocHJlZGljYXRlOiBQcmVkaWNhdGU8VD4sIGFycmF5OiBUW10pOiBNYXliZTxUPjtcbmV4cG9ydCBmdW5jdGlvbiBmaW5kPFQ+KHByZWRpY2F0ZTogUHJlZGljYXRlPFQ+KTogKGFycmF5OiBUW10pID0+IE1heWJlPFQ+O1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmQ8VD4oXG4gIHByZWRpY2F0ZTogUHJlZGljYXRlPFQ+LFxuICBhcnJheT86IFRbXVxuKTogTWF5YmU8VD4gfCAoKGFycmF5OiBUW10pID0+IE1heWJlPFQ+KSB7XG4gIGNvbnN0IG9wID0gKGE6IFRbXSkgPT4gTWF5YmUub2YoYS5maW5kKHByZWRpY2F0ZSkpO1xuICByZXR1cm4gY3VycnkxKG9wLCBhcnJheSk7XG59XG5cbi8qKlxuICBTYWZlbHkgZ2V0IHRoZSBmaXJzdCBpdGVtIGZyb20gYSBsaXN0LCByZXR1cm5pbmcgYEp1c3RgIHRoZSBmaXJzdCBpdGVtIGlmIHRoZVxuICBhcnJheSBoYXMgYXQgbGVhc3Qgb25lIGl0ZW0gaW4gaXQsIG9yIGBOb3RoaW5nYCBpZiBpdCBpcyBlbXB0eS5cblxuICAjIyBFeGFtcGxlc1xuXG4gIGBgYHRzXG4gIGxldCBlbXB0eSA9IFtdO1xuICBNYXliZS5oZWFkKGVtcHR5KTsgLy8gPT4gTm90aGluZ1xuXG4gIGxldCBmdWxsID0gWzEsIDIsIDNdO1xuICBNYXliZS5oZWFkKGZ1bGwpOyAvLyA9PiBKdXN0KDEpXG4gIGBgYFxuXG4gIEBwYXJhbSBhcnJheSBUaGUgYXJyYXkgdG8gZ2V0IHRoZSBmaXJzdCBpdGVtIGZyb20uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZWFkPFQ+KGFycmF5OiBBcnJheTxUIHwgbnVsbCB8IHVuZGVmaW5lZD4pOiBNYXliZTxUPiB7XG4gIHJldHVybiBNYXliZS5vZihhcnJheVswXSk7XG59XG5cbi8qKiBBIGNvbnZlbmllbmNlIGFsaWFzIGZvciBgTWF5YmUuaGVhZGAuICovXG5leHBvcnQgY29uc3QgZmlyc3QgPSBoZWFkO1xuXG4vKipcbiAgU2FmZWx5IGdldCB0aGUgbGFzdCBpdGVtIGZyb20gYSBsaXN0LCByZXR1cm5pbmcgYEp1c3RgIHRoZSBsYXN0IGl0ZW0gaWYgdGhlXG4gIGFycmF5IGhhcyBhdCBsZWFzdCBvbmUgaXRlbSBpbiBpdCwgb3IgYE5vdGhpbmdgIGlmIGl0IGlzIGVtcHR5LlxuXG4gICMjIEV4YW1wbGVzXG5cbiAgYGBgdHNcbiAgbGV0IGVtcHR5ID0gW107XG4gIE1heWJlLmxhc3QoZW1wdHkpOyAvLyA9PiBOb3RoaW5nXG5cbiAgbGV0IGZ1bGwgPSBbMSwgMiwgM107XG4gIE1heWJlLmxhc3QoZnVsbCk7IC8vID0+IEp1c3QoMylcbiAgYGBgXG5cbiAgQHBhcmFtIGFycmF5IFRoZSBhcnJheSB0byBnZXQgdGhlIGZpcnN0IGl0ZW0gZnJvbS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxhc3Q8VD4oYXJyYXk6IEFycmF5PFQgfCBudWxsIHwgdW5kZWZpbmVkPik6IE1heWJlPFQ+IHtcbiAgcmV0dXJuIE1heWJlLm9mKGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdKTtcbn1cblxuLyoqXG4gIENvbnZlcnQgdGhlIGFyZ3VtZW50cyB0byBhIHNpbmdsZSBgTWF5YmVgLiBVc2VmdWwgZm9yIGRlYWxpbmcgd2l0aCBhcnJheXMgb2ZcbiAgYE1heWJlYHMsIHZpYSB0aGUgc3ByZWFkIG9wZXJhdG9yLlxuXG4gICMjIEV4YW1wbGVzXG5cbiAgYGBgdHNcbiAgaW1wb3J0IE1heWJlIGZyb20gJ3RydWUtbXl0aC9tYXliZSc7XG5cbiAgbGV0IHZhbGlkID0gW01heWJlLmp1c3QoMiksIE1heWJlLmp1c3QoJ3RocmVlJyldO1xuICBNYXliZS5hbGwoLi4udmFsaWQpOyAvLyA9PiBKdXN0KFsyLCAndGhyZWUnXSk7XG5cbiAgbGV0IGludmFsaWQgPSBbTWF5YmUuanVzdCgyKSwgTWF5YmUubm90aGluZzxzdHJpbmc+KCldO1xuICBNYXliZS5hbGwoLi4uaW52YWxpZCk7IC8vID0+IE5vdGhpbmdcbiAgYGBgXG5cbiAgIyMgTm90ZSBvbiBTcHJlYWRcblxuICBUaGlzIHJlcXVpcmVzIHRoZSB1c2Ugb2YgdGhlIHNwcmVhZCBvcGVyYXRvciBiZWNhdXNlIChhdCBsZWFzdCBhcyBvZlxuICBUeXBlU2NyaXB0IDMuMCksIHRoZSB0eXBlIGluZmVyZW5jZSBmYWxscyBkb3duIHdoZW4gYXR0ZW1wdGluZyB0byBidWlsZCB0aGlzXG4gIHNhbWUgdHlwZSB3aXRoIGFuIGFycmF5IGRpcmVjdGx5LiBNb3Jlb3ZlciwgdGhpcyBzcHJlYWQtYmFzZWQgYXBwcm9hY2ggaGFuZGxlc1xuICBoZXRlcmVnZW5vdXMgYXJyYXlzOyBUUyAqYWxzbyogZmFpbHMgdG8gaW5mZXIgY29ycmVjdGx5IGZvciBhbnl0aGluZyBidXRcbiAgaG9tb2dlbmVvdXMgYXJyYXlzIHdoZW4gdXNpbmcgdGhhdCBhcHByb2FjaC5cblxuICBAcGFyYW0gYXJncyBUaGUgYE1heWJlYHMgdG8gcmVzb2x2ZSB0byBhIHNpbmdsZSBgTWF5YmVgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWxsPFQgZXh0ZW5kcyBNYXliZTxhbnk+PihcbiAgLi4uYXJnczogVFtdXG4pOiBUIGV4dGVuZHMgTWF5YmU8aW5mZXIgVT4gPyBNYXliZTxVW10+IDogbmV2ZXIge1xuICAvLyBAdHMtaWdub3JlIC0tIHRoaXMgaXMgaW5kZWVkIHRoZSBjb3JyZWN0IGltcGxlbWVudGF0aW9uLCBidXQgVFMgZG9lc24ndFxuICAvLyAgICAgICAgICAgICAgIGNvcnJlY3RseSBwYXJzZSB0aGUgdHlwZXMgaW4gdGhlIGNvbnRleHQgb2YgYHJlZHVjZWAuXG4gIHJldHVybiBhcmdzLnJlZHVjZShcbiAgICAocmVzdWx0LCBtYXliZSkgPT4gcmVzdWx0LmFuZFRoZW4oYXMgPT4gbWF5YmUubWFwKGEgPT4gYXMuY29uY2F0KGEpKSksXG4gICAgTWF5YmUuanVzdChbXSBhcyBUW10pXG4gICk7XG59XG5cbi8qKlxuICBHaXZlbiBhIHR1cGxlIG9mIGBNYXliZWBzLCByZXR1cm4gYSBgTWF5YmVgIG9mIHRoZSB0dXBsZSB2YWx1ZXMuXG5cbiAgR2l2ZW4gYSB0dXBsZSBvZiB0eXBlIGBbTWF5YmU8QT4sIE1heWJlPEI+XWAsIHRoZSByZXN1bHRpbmcgdHlwZSBpc1xuICBgTWF5YmU8W0EsIEJdPmAuIFdvcmtzIHdpdGggdXAgdG8gYSA1LXR1cGxlLiAoSWYgeW91J3JlIGRvaW5nIG1vcmUgdGhhbiBhXG4gIDUtdHVwbGUsIHdoYXQgYXJlIHlvdSBkb2luZz8/PylcblxuICAjIyBFeGFtcGxlc1xuXG4gIElmIGFueSBvZiB0aGUgaXRlbXMgaW4gdGhlIHR1cGxlIGFyZSBgTm90aGluZ2AsIHRoZSB3aG9sZSByZXN1bHQgaXMgYE5vdGhpbmdgLlxuICBIZXJlLCBmb3IgZXhhbXBsZSwgYHJlc3VsdGAgaGFzIHRoZSB0eXBlIGBNYXliZTxbc3RyaW5nLCBudW1iZXJdPmAgYW5kIHdpbGwgYmVcbiAgYE5vdGhpbmdgOlxuXG4gIGBgYHRzXG4gIGltcG9ydCBNYXliZSBmcm9tICd0cnVlLW15dGgvbWF5YmUnO1xuXG4gIHR5cGUgVHVwbGUgPSBbTWF5YmU8c3RyaW5nPiwgTWF5YmU8bnVtYmVyPl07XG5cbiAgbGV0IGludmFsaWQ6IFR1cGxlID0gW01heWJlLmp1c3QoJ3dhdCcpLCBNYXliZS5ub3RoaW5nKCldO1xuICBsZXQgcmVzdWx0ID0gTWF5YmUudHVwbGUoaW52YWxpZCk7ICAvLyA9PiBOb3RoaW5nXG4gIGBgYFxuXG4gIElmIGFsbCBvZiB0aGUgaXRlbXMgaW4gdGhlIHR1cGxlIGFyZSBgSnVzdGAsIHRoZSByZXN1bHQgaXMgYEp1c3RgIHdyYXBwaW5nIHRoZVxuICB0dXBsZSBvZiB0aGUgdmFsdWVzIG9mIHRoZSBpdGVtcy4gSGVyZSwgZm9yIGV4YW1wbGUsIGByZXN1bHRgIGFnYWluIGhhcyB0aGVcbiAgdHlwZSBgTWF5YmU8W3N0cmluZywgbnVtYmVyXT5gIGFuZCB3aWxsIGJlIGBKdXN0KFsnaGV5JywgMTJdYDpcblxuICBgYGB0c1xuICBpbXBvcnQgTWF5YmUgZnJvbSAndHJ1ZS1teXRoL21heWJlJztcblxuICB0eXBlIFR1cGxlID0gW01heWJlPHN0cmluZz4sIE1heWJlPG51bWJlcj5dO1xuXG4gIGxldCB2YWxpZDogVHVwbGUgPSBbTWF5YmUuanVzdCgnaGV5JyksIE1heWJlLmp1c3QoMTIpXTtcbiAgbGV0IHJlc3VsdCA9IE1heWJlLnR1cGxlKHZhbGlkKTsgIC8vID0+IEp1c3QoWydoZXknLCAxMl0pXG4gIGBgYFxuXG4gIEBwYXJhbSBtYXliZXM6IHRoZSB0dXBsZSBvZiBgTWF5YmVgcyB0byBjb252ZXJ0IHRvIGEgYE1heWJlYCBvZiB0dXBsZSB2YWx1ZXMuXG4gKi9cbi8vIEB0cy1pZ25vcmUgLS0gdGhpcyBkb2Vzbid0IHR5cGUtY2hlY2ssIGJ1dCBpdCBpcyBjb3JyZWN0IVxuZXhwb3J0IGZ1bmN0aW9uIHR1cGxlPFQsIFU+KG1heWJlczogW01heWJlPFQ+LCBNYXliZTxVPl0pOiBNYXliZTxbVCwgVV0+O1xuZXhwb3J0IGZ1bmN0aW9uIHR1cGxlPFQsIFUsIFY+KG1heWJlczogW01heWJlPFQ+LCBNYXliZTxVPiwgTWF5YmU8Vj5dKTogTWF5YmU8W1QsIFUsIFZdPjtcbmV4cG9ydCBmdW5jdGlvbiB0dXBsZTxULCBVLCBWLCBXPihcbiAgbWF5YmVzOiBbTWF5YmU8VD4sIE1heWJlPFU+LCBNYXliZTxWPiwgTWF5YmU8Vz5dXG4pOiBNYXliZTxbVCwgVSwgViwgV10+O1xuZXhwb3J0IGZ1bmN0aW9uIHR1cGxlPFQsIFUsIFYsIFcsIFg+KFxuICBtYXliZXM6IFtNYXliZTxUPiwgTWF5YmU8VT4sIE1heWJlPFY+LCBNYXliZTxXPiwgTWF5YmU8WD5dXG4pOiBNYXliZTxbVCwgVSwgViwgVywgWF0+IHtcbiAgLy8gQHRzLWlnbm9yZSAtLSB0aGlzIGRvZXNuJ3QgdHlwZS1jaGVjaywgYnV0IGl0IGlzIGNvcnJlY3QhXG4gIHJldHVybiBhbGwoLi4ubWF5YmVzKTtcbn1cblxuLyoqIEEgdmFsdWUgd2hpY2ggbWF5IChgSnVzdDxUPmApIG9yIG1heSBub3QgKGBOb3RoaW5nYCkgYmUgcHJlc2VudC4gKi9cbmV4cG9ydCB0eXBlIE1heWJlPFQ+ID0gSnVzdDxUPiB8IE5vdGhpbmc8VD47XG5leHBvcnQgY29uc3QgTWF5YmUgPSB7XG4gIFZhcmlhbnQsXG4gIEp1c3QsXG4gIE5vdGhpbmcsXG4gIGFsbCxcbiAgaXNKdXN0LFxuICBpc05vdGhpbmcsXG4gIGp1c3QsXG4gIG5vdGhpbmcsXG4gIG9mLFxuICBmaW5kLFxuICBmaXJzdCxcbiAgZnJvbU51bGxhYmxlLFxuICBoZWFkLFxuICBsYXN0LFxuICBtYXAsXG4gIG1hcE9yLFxuICBtYXBPckVsc2UsXG4gIGFuZCxcbiAgYW5kVGhlbixcbiAgY2hhaW4sXG4gIGZsYXRNYXAsXG4gIG9yLFxuICBvckVsc2UsXG4gIHVuc2FmZWx5VW53cmFwLFxuICB1bnNhZmVseUdldCxcbiAgdW5zYWZlR2V0LFxuICB1bndyYXBPcixcbiAgZ2V0T3IsXG4gIHVud3JhcE9yRWxzZSxcbiAgZ2V0T3JFbHNlLFxuICB0b09rT3JFcnIsXG4gIHRvT2tPckVsc2VFcnIsXG4gIGZyb21SZXN1bHQsXG4gIHRvU3RyaW5nLFxuICB0dXBsZSxcbiAgbWF0Y2gsXG4gIGNhdGEsXG4gIGVxdWFscyxcbiAgYXAsXG4gIGlzSW5zdGFuY2UsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBNYXliZTtcbiJdfQ==